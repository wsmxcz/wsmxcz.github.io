[{"content":" 匹配规则 # 在编辑Markdown时，特别是在页面渲染应用场景下，数学公式往往需要特定的转义定界符，这里我列出了一些常用定界符的正则表达式，以实现快速的批量匹配：\n行内公式 \\(...\\): (?\u0026lt;!\\\\)\\\\\\((.*?)(?\u0026lt;!\\\\)\\\\\\) \\\\(...\\\\): (?\u0026lt;!\\\\)\\\\\\\\\\((.*?)(?\u0026lt;!\\\\)\\\\\\\\\\) $...$: (?\u0026lt;!\\$)\\$(?!\\$)(.*?)(?\u0026lt;!\\$)\\$(?!\\$) 行间公式 \\[...\\]: (?\u0026lt;!\\\\)\\\\\\[\\n(.*?)\\n(?\u0026lt;!\\\\)\\\\\\] \\\\[...\\\\]: (?\u0026lt;!\\\\)\\\\\\\\\\[\\n(.*?)\\n(?\u0026lt;!\\\\)\\\\\\\\\\] $$...$$: (?\u0026lt;!\\$)\\$\\$(?!\\$)\\n(.*?)\\n(?\u0026lt;!\\$)\\$\\$(?!\\$) \\begin{equation}...\\end{equation} (?\u0026lt;!\\\\)\\\\begin{equation}\\n(.*?)\\n(?\u0026lt;!\\\\)\\\\end{equation} 这里使用负向回顾断言（(?\u0026lt;!\\\\)、(?\u0026lt;!\\$)）和负向前瞻断言（(?!\\\\\\$、(?!\\$）来避免分隔符之间的冲突（例如，$...$ 与 $$...$$）。对于行间公式，加入了换行符\\n，如果不需要可以删去。\n替换规则 # 匹配完成后常常需要替换，使用基本的逻辑即可，列出如下：\n\\(...\\): \\\\\\($1\\\\\\) \\\\(...\\\\): \\\\\\\\($1\\\\\\\\) $...$: $$$1$$ \\[...\\]: \\\\[\\n$\\n1\\\\] \\\\[...\\\\]: \\\\\\\\[\\n$1\\n\\\\\\\\] $$...$$: $$$$\\n$1\\n$$$$ \\begin{equation}...\\end{equation} \\begin{equation}\\n$1\\n\\end{equation} ","date":"2025-03-15","externalUrl":null,"permalink":"/zh-cn/utilities/unifying-multi-format-mathematical-formula-delimiters-via-regular-expressions/test/","section":"Utilities","summary":"\u003ch3 class=\"relative group\"\u003e匹配规则 \n    \u003cdiv id=\"%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cp\u003e在编辑Markdown时，特别是在页面渲染应用场景下，数学公式往往需要特定的转义定界符，这里我列出了一些常用定界符的正则表达式，以实现快速的批量匹配：\u003c/p\u003e","title":"基于正则表达式统一匹配替换多格式数学公式定界符","type":"utilities"},{"content":"My name is Zheng (Alex) Che. I earned a Bachelor\u0026rsquo;s degree from the Cuiying Honors College of Lanzhou University. I\u0026rsquo;m currently pursuing a Master\u0026rsquo;s degree at the University of Science and Technology of China.\nMy research interests center on employing neural networks, quantum computing, and other advanced computational methods to explore quantum many-body systems, particularly focusing on the structure and properties of electronic systems.\nIn addition, I have a keen interest in fundamental and cutting-edge topics in mathematics, physics, and computer science.\n","date":"2025-03-19","externalUrl":null,"permalink":"/zh-cn/aboutme/","section":"如我所见","summary":"\u003cp\u003eMy name is Zheng (Alex) Che. I earned a Bachelor\u0026rsquo;s degree from the Cuiying Honors College of Lanzhou University. I\u0026rsquo;m currently pursuing a Master\u0026rsquo;s degree at the University of Science and Technology of China.\u003c/p\u003e","title":"关于我","type":"page"},{"content":"","date":"2025-03-19","externalUrl":null,"permalink":"/zh-cn/","section":"如我所见","summary":"","title":"如我所见","type":"page"},{"content":"","date":"2025-03-17","externalUrl":null,"permalink":"/zh-cn/series/determinant-based-quantum-chemistry/","section":"Series","summary":"","title":"Determinant-Based Quantum Chemistry","type":"series"},{"content":"","date":"2025-03-17","externalUrl":null,"permalink":"/zh-cn/docs/","section":"Docs","summary":"","title":"Docs","type":"docs"},{"content":"","date":"2025-03-17","externalUrl":null,"permalink":"/zh-cn/series/group-theory/","section":"Series","summary":"","title":"Group Theory","type":"series"},{"content":" 概述 # 对于无结构的搜索问题，Grover 算法相较于经典算法从理论上提供了平方根级别的加速。\n无结构搜索问题 # 无结构搜索问题可以形式化为：\n经典搜索问题：\nInput: 问题的规模 \\(n \\in \\mathbb{N} \\)，一个能够执行函数 \\(f: \\{0,1\\}^n \\rightarrow \\{0,1\\}\\) 的 Oracle.\nOutput: 一个满足 \\(f(\\mathbf{x})=1\\) 的string \\(\\mathbf{x}\\).\n这个问题可以有一些变体，例如我们可以先验设定问题解的数量（不存在解，只有唯一解，存在多个解等）。\n限制函数的输入域为 \\(\\mathbb{Z}_{2^n}\\) 并不会缩小或特化问题适用的范围，但可以帮助我们简化问题。对于任意的 \\(N \\in \\mathbb{Z}_{2^n}\\) 和任意函数 \\(f: \\mathbb{Z}_N \\rightarrow \\{0, 1\\}\\)，我们可以将 \\(\\mathbb{Z}_N\\) 嵌入到 \\(\\mathbb{Z}_{2^n}\\,|\\, n = [\\log_2 N]\\) 中，并规定超出范围的输入返回0。\n很容易想象到，在经典计算机上求解此问题，在最坏的情形下，需要调用Oracle \\(2^n\\) 次（遍历整个问题空间，理论上界）。但量子计算机上执行的 Grover 算法能够提供平方根级的加速，将调用次数的理论上界减少至 \\(2^{n-1}\\)。\nGrover 算法 # 我们此处设定问题解的数量是有限的。Grover算法需要两个寄存器：寄存器1包含 \\(n\\) 个量子比特，用于存储数据信息；寄存器2包含一个量子比特，用以存储条件函数 \\(f(x)\\) 的值。首先将寄存器1中的量子比特制备至最大叠加态（利用 \\(H^{\\otimes n}\\)），寄存器2制备到 \\(\\ket{-}\\) 态。因此，整个系统初始处于量子态： $$ \\ket{\\Phi_0} = \\frac{1}{\\sqrt{N}} \\sum_{\\mathbf{x}\\in \\{0,1\\}^n} \\ket{\\mathbf{x}} \\otimes \\ket{-} $$\nGrover算法使用一个酉算符 \\(U_f\\) 实现搜索算法中的函数 \\(f\\)，定义为： $$ U_f : \\mathcal{H}^n \\otimes \\mathcal{H}^1 \\rightarrow \\mathcal{H}^n \\otimes \\mathcal{H}^1 $$ $$ U_f \\ket{\\mathbf{x}}\\ket{y} = \\ket{\\mathbf{x}} \\ket{f(\\mathbf{x}) \\oplus y} = \\ket{\\mathbf{x}} X^{f(\\mathbf{x})} \\ket{y} $$\n基于此，我们可以定义无结构搜索问题的量子版本：\n量子搜索问题：\nInput: 问题的规模 \\(n \\in \\mathbb{N} \\)，一个能够实现上述 \\(U_f\\) 的 Oracle。 \\(M=|f^{-1}(1)|, M\u0026gt;0\\)\nOutput: 一个满足 \\(f(\\mathbf{x})=1\\) 的string \\(\\mathbf{x}\\).\n我们下面说明，不施加任何额外操作，直接测量寄存器1即可得到结果。寄存器1的量子态可以写为： $$ \\ket{s} = \\frac{1}{\\sqrt{N}} \\sum_{\\mathbf{x}\\in \\{0,1\\}^n} \\ket{\\mathbf{x}} $$\n我们设定： $$ \\ket{s_0} = \\frac{1}{\\sqrt{N}} \\sum_{\\mathbf{x}\\in \\{0,1\\}^n, f(\\mathbf{x})=0} \\ket{\\mathbf{x}} $$ $$ \\ket{s_1} = \\frac{1}{\\sqrt{N}} \\sum_{\\mathbf{x}\\in \\{0,1\\}^n, f(\\mathbf{x})=1} \\ket{\\mathbf{x}} $$ $$ \\theta = \\arcsin{\\sqrt{M/N}} $$\n那么我们可以将寄存器1的量子态写为： $$ \\ket{s} = \\sqrt{\\frac{N-M}{N}} \\ket{s_0} + \\sqrt{\\frac{M}{N}} \\ket{s_1} = \\cos{\\theta}\\ket{s_0} + \\sin{\\theta} \\ket{s_1} $$\n在 \\(\\mathcal{H}^n\\) 的计算基上测量 \\(\\ket{s}\\)，就可以得到获得满足 \\(f(\\mathbf{x})=1\\) 的 \\(\\mathbf{x}\\) 的概率： $$ p = \\sin^2{\\theta} = \\frac{M}{N} $$ 这代表了正确得到搜索问题解的概率，相比经典策略并没有提供任何优势。\n为了找出可能存在的量子优势，我们需要一种称为“振幅放大”的技术，这可以提高目标态 \\(\\ket{s_1}\\) 的振幅从而增大获得正确答案的概率。振幅放大操作需要利用一种称为 Grover 迭代器的酉算符 \\(G\\)，定义为： $$ G (\\cos{\\alpha}\\ket{s_0} + \\sin{\\alpha} \\ket{s_1}) = \\cos{(\\alpha+2\\theta)}\\ket{s_0} + \\sin{(\\alpha + 2 \\theta)} \\ket{s_1}, \\forall \\alpha \\in \\mathbb{R} $$\n对寄存器1施加 \\(k \\in \\mathbb{N_0}\\) 次Grover迭代器，就可以得到： $$ G^k \\ket{s} = \\cos{(2k+1)\\theta} \\ket{s_0} + \\sin{(2k+1)\\theta} \\ket{s_1} $$\n至此，我们可以描述出 Grover 算法的整个流程（只考虑寄存器1）。首先，我们制备出初始的最大叠加态 \\(\\ket{s}\\)，然后对 \\(\\ket{s}\\) 施加 \\(k\\) 次 Grover迭代器，最后在 \\(\\mathcal{H}^n\\) 的计算基上测量 \\(\\ket{s}\\) 得到结果。Grover迭代器的施加次数 \\(k\\) 取决于 \\(2(k+1)\\theta\\) 与 \\(\\pi/2\\) 的接近程度，这会让得到正确解的概率最大化。\nGrover搜索算法的量子线路示意图 自然的我们会提出几个问题：\nGrover 迭代器怎么具体实现？特别是我们在算法输入中只给定了一个实现 \\(U_f\\) 操作的 Oracal。 Grover 迭代器的最小次数是多少？我们自然希望量子线路越短越好。 量子方案相较于经典方案的优势在哪里？ 我们将在以下几节的内容中一一给出答案。\nGrover 迭代器 # 我们现在说明如何 Grover 迭代器的具体实现以及性质。Grover 迭代器的构建依赖于两个作用在 \\(\\mathcal{H}^n\\) 上的酉算符： $$ U_{\\omega} = I - 2\\ket{s_1}\\bra{s_1} $$ $$ U_s = 2\\ket{s}\\bra{s} - I $$\n其中，\\(U_{\\omega}\\) 作用于 \\(\\ket{s}\\) 会翻转 \\(\\ket{s_1}\\) 的振幅，而 \\(U_s\\) 作用于 \\(\\ket{s}\\) 会翻转整个 \\(\\mathcal{H}^n\\) 的振幅。我们可以证明，Grover 迭代器可以通过以下方式构建： $$ G = U_{\\omega} U_s $$\n容易验证，$U_\\omega$, $U_s$ 和 $G$ 都是酉算符。$U_\\omega$, $U_s$ 同时也是厄米算符。这些算符都具有明确的几何意义，我们进行简单的研究。定义一个由 $\\ket{s_0}$ 和 $\\ket{s_1}$ 张成的二维复平面 $\\mathcal{P}$： $$ P = \\mathbb{C} \\ket{s_0} + \\mathbb{C} \\ket{s_1} $$ 显然，$\\ket{s_0}$ 和 $\\ket{s_1}$ 是 $\\mathcal{P}$ 的一组正交基。$U_{\\omega}$ 的\n","date":"2025-03-17","externalUrl":null,"permalink":"/zh-cn/docs/quantum-algorithm/grover/","section":"Docs","summary":"\u003ch2 class=\"relative group\"\u003e概述 \n    \u003cdiv id=\"%E6%A6%82%E8%BF%B0\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E6%A6%82%E8%BF%B0\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e对于无结构的搜索问题，Grover 算法相较于经典算法从理论上提供了平方根级别的加速。\u003c/p\u003e","title":"Grover算法","type":"docs"},{"content":"","date":"2025-03-17","externalUrl":null,"permalink":"/zh-cn/series/quantum-algorithm/","section":"Series","summary":"","title":"Quantum Algorithm","type":"series"},{"content":"","date":"2025-03-17","externalUrl":null,"permalink":"/zh-cn/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":" 为什么要研究群表示论？ # 在第一节中，我们介绍了群的基本定义以及群理论中的一些基本概念，我们使用的数学语言是“抽象”的，这不利于群论的进一步应用。群表示论（更正式地，线性表示理论）就是为了解决这一问题，它可以帮助我们将抽象的群结构具体化到线性变换或矩阵上，使得我们能用线性代数、矩阵论等成熟的工具去分析群的性质。\n群的线性表示 # 定义: 设 \\(G\\) 是一个群，\\(V\\) 是域 \\(K\\) 上的一个向量空间，\\(V\\) 上所有可逆线性变换组成的乘法群记作 \\(\\mathrm{GL}(V)\\)。\\(G\\) 到 \\(\\mathrm{GL}(V)\\) 的一个群同态 \\(\\varphi\\) 称为 \\(G\\) 在域 \\(K\\) 上的一个线性表示（简称为 \\(K\\)-表示或者表示）。\\(V\\) 称为表示空间。若 \\(V\\) 是有限维的，则 \\(V\\) 的维数 \\(\\dim_K V\\) 称为表示的次数（或维数），记作 \\(\\deg \\varphi\\) ；若 \\(V\\) 是无限维的，则称 \\(\\varphi \\) 是 \\(G\\) 的无限维表示。\n","date":"2025-03-17","externalUrl":null,"permalink":"/zh-cn/docs/summary-of-group-theory/group2/","section":"Docs","summary":"\u003ch2 class=\"relative group\"\u003e为什么要研究群表示论？ \n    \u003cdiv id=\"%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%A0%94%E7%A9%B6%E7%BE%A4%E8%A1%A8%E7%A4%BA%E8%AE%BA\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%A0%94%E7%A9%B6%E7%BE%A4%E8%A1%A8%E7%A4%BA%E8%AE%BA\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e在第一节中，我们介绍了群的基本定义以及群理论中的一些基本概念，我们使用的数学语言是“抽象”的，这不利于群论的进一步应用。群表示论（更正式地，线性表示理论）就是为了解决这一问题，它可以帮助我们将抽象的群结构具体化到线性变换或矩阵上，使得我们能用线性代数、矩阵论等成熟的工具去分析群的性质。\u003c/p\u003e","title":"群论：群表示论","type":"docs"},{"content":" 概述 # 在现代量子化学中，行列式驱动的方法，如 Hartree-Fock (HF) 及其后继的 post-HF 方法，因其在处理多电子系统时展现出计算效率与精度的卓越平衡而占据核心地位。这些方法的理论基础深深植根于 二次量子化 的表述。二次量子化作为标准量子力学在多体问题中的一种优雅而强大的语言，通过引入 产生算符 \\(a_p^\\dagger\\) 和 湮灭算符 \\(a_p\\)，能够灵活地构造 Fock 空间 中的任意算符，例如哈密顿量和波函数。这种框架不仅精简了复杂量子系统的数学描述，更关键的是，它通过算符之间的 反对易关系，自动确保了电子作为费米子所要求的波函数反对称性。这一特性在计算化学中至关重要，是行列式驱动方法能够高效实现的关键。\nSlater 行列式的构造与反对称性 # 考虑一个由 \\(N\\) 个电子组成的分子系统，其电子结构在一组 \\(M\\) 个正交 自旋轨道 \\({\\phi_p(\\mathbf{x})}_{p=1}^M\\) 下描述，其中 \\(\\mathbf{x} = (\\mathbf{r}, \\sigma)\\) 表示电子的空间坐标 \\(\\mathbf{r}\\) 和自旋 \\(\\sigma\\)。这些自旋轨道被视为单粒子基函数，其具体形式在此不作深入讨论。根据 泡利不相容原理，多电子波函数必须在交换任意两个电子坐标时表现出反对称性。在 一次量子化 中，这一性质通过 反对称化算符 \\(\\hat{A}\\) 实现：\n$$ \\hat{A} = \\frac{1}{\\sqrt{N!}} \\sum_{P \\in S_N} \\epsilon(P) P, $$\n其中 \\(S_N\\) 是 \\(N\\) 阶置换群，\\(P\\) 为置换操作，\\(\\epsilon(P)\\) 表示置换的奇偶性（+1 为偶置换，-1 为奇置换）。将 \\(\\hat{A}\\) 作用于 \\(N\\) 个自旋轨道的简单乘积态（即 Hartree 积）：\n$$ \\Phi_{\\text{Hartree}} = \\phi_{p_1}(\\mathbf{x}_1) \\phi_{p_2}(\\mathbf{x}_2) \\cdots \\phi_{p_N}(\\mathbf{x}_N), $$\n即可得到归一化的 Slater 行列式：\n$$ \\Phi_{p_1 p_2 \\cdots p_N}(\\mathbf{x}_1, \\dots, \\mathbf{x}_N) = |\\phi_{p_1} \\phi_{p_2} \\cdots \\phi_{p_N}| = \\frac{1}{\\sqrt{N!}} \\begin{vmatrix} \\phi_{p_1}(\\mathbf{x}_1) \u0026amp; \\phi_{p_2}(\\mathbf{x}_1) \u0026amp; \\cdots \u0026amp; \\phi_{p_N}(\\mathbf{x}_1) \\\\ \\phi_{p_1}(\\mathbf{x}_2) \u0026amp; \\phi_{p_2}(\\mathbf{x}_2) \u0026amp; \\cdots \u0026amp; \\phi_{p_N}(\\mathbf{x}_2) \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ \\phi_{p_1}(\\mathbf{x}_N) \u0026amp; \\phi_{p_2}(\\mathbf{x}_N) \u0026amp; \\cdots \u0026amp; \\phi_{p_N}(\\mathbf{x}_N) \\\\ \\end{vmatrix}. $$\nSlater 行列式的代数结构天然满足反对称性：交换任意两个电子坐标 \\(\\mathbf{x}_i\\) 和 \\(\\mathbf{x}_j\\)，波函数变号：\n$$ \\Phi(\\cdots, \\mathbf{x}_i, \\cdots, \\mathbf{x}_j, \\cdots) = -\\Phi(\\cdots, \\mathbf{x}_j, \\cdots, \\mathbf{x}_i, \\cdots), $$\n这与行列式交换两行引入负号的性质一致。\n从数学视角看，Slater 行列式是 \\(N\\) 个自旋轨道在 外代数（Exterior Algebra） 中的 楔积（Wedge Product） 在特定坐标表象下的实现：\n$$ \\phi_{p_1} \\wedge \\phi_{p_2} \\wedge \\cdots \\wedge \\phi_{p_N} = \\frac{1}{\\sqrt{N!}} \\sum_{P \\in S_N} \\epsilon(P) \\phi_{P(p_1)} \\otimes \\phi_{P(p_2)} \\otimes \\cdots \\otimes \\phi_{P(p_N)}. $$\n楔积是构造反对称张量的普适方法，而 Slater 行列式则是其在电子坐标空间中的矩阵表达。在量子化学中，“行列式”、“反对称积”和“Slater 行列式”常互换使用，但需明确行列式是这一概念在特定基函数下的具体形式。\n二次量子化与 Fock 空间 # 二次量子化 将反对称性的处理提升至更高的抽象层次，并融入 Fock 空间 的代数结构。Fock 空间是由所有可能粒子数（包括真空态）的反对称态张成的希尔伯特空间。对于 \\(N\\) 电子系统，其状态空间是 Fock 空间的一个子空间。该空间的基矢（即 Slater 行列式）可通过 占据数（Occupation Number, ON）向量 \\((n_1, n_2, \\ldots, n_M)\\) 唯一标识，其中 \\(n_p = 1\\) 表示自旋轨道 \\(\\phi_p\\) 被占据，\\(n_p = 0\\) 表示空轨道，且 \\(\\sum_p n_p = N\\)。例如，Slater 行列式 \\(|\\phi_{p_1} \\cdots \\phi_{p_N}|\\) 对应 ON 态 \\(|n_1, \\ldots, n_M\\rangle\\)，其中仅当 \\(p \\in {p_1, \\ldots, p_N}\\) 时 \\(n_p = 1\\)，其余为 0。这种表示将多电子波函数从依赖 \\(N\\) 个显式坐标的函数简化为离散轨道占据信息的抽象态矢量，大幅简化了表示和运算。\n尽管一次量子化中的 Slater 行列式（坐标空间函数）与二次量子化中的 ON 态（Fock 空间基矢）形式不同，它们描述的是同一个 \\(N\\) 电子反对称量子态，具有等价的物理意义。在量子化学中，这两种表述（以及通过产生算符作用于真空态生成的 Fock 态）常交替使用，具体取决于上下文。\n反对称性的算符代数实现 # 在二次量子化中，费米子的反对称性由 产生算符 \\(a_p^\\dagger\\) 和湮灭算符 \\(a_p\\) 的反对易关系 保证：\n$$ { a_p, a_q^\\dagger } = a_p a_q^\\dagger + a_q^\\dagger a_p = \\delta_{pq}, $$\n$$ { a_p, a_q } = a_p a_q + a_q a_p = 0, $$\n$$ { a_p^\\dagger, a_q^\\dagger } = a_p^\\dagger a_q^\\dagger + a_q^\\dagger a_p^\\dagger = 0. $$\n其中，\\(a_p^\\dagger\\) 在真空态 \\(|\\text{vac}\\rangle\\) 上产生一个占据 \\(\\phi_p\\) 的电子，\\(a_p\\) 则湮灭之。任意 \\(N\\) 电子 Slater 行列式可表示为：\n$$ | \\Phi_{p_1 p_2 \\cdots p_N} \\rangle = a_{p_1}^\\dagger a_{p_2}^\\dagger \\cdots a_{p_N}^\\dagger | \\text{vac} \\rangle. $$\n由于 \\({a_p^\\dagger, a_q^\\dagger} = 0\\)，即 \\(a_p^\\dagger a_q^\\dagger = -a_q^\\dagger a_p^\\dagger\\)，交换两个产生算符引入负号：\n$$ \\cdots a_{p_j}^\\dagger \\cdots a_{p_i}^\\dagger \\cdots | \\text{vac} \\rangle = - \\cdots a_{p_i}^\\dagger \\cdots a_{p_j}^\\dagger \\cdots | \\text{vac} \\rangle, $$\n这与 Slater 行列式交换行列的性质一致。此外，\\(a_p^\\dagger a_p^\\dagger = 0\\) 直接反映了泡利原理——同一自旋轨道不可重复占据。因此，二次量子化通过算符代数隐式保证反对称性，无需显式构造行列式。\nSlater行列式（ON向量）的计算机存储 # 我们前面提到，Slater行列式和 ON 向量在Fock空间表述下的量子化学中是物理等价的两个概念。在接下来的内容中，我们将混合使用这两个名词。\n在Fock空间中，单个Slater行列式可以简洁地表示为一个长度为 \\(N_{SO}\\) 的向量，其中 \\(N_{SO}\\) 代表自旋轨道的总数。向量的每个元素取值为0（未占据）或1（占据）。例如，\\( |1,1,0,0,0,0\\rangle \\) 表示一个包含6个自旋轨道的体系，其中前两个自旋轨道被电子占据。然而，在计算机中高效存储和操作这些行列式时，直接使用这种显式向量形式并不理想，通常会采用更紧凑且运算效率更高的**位串（bitstring）**编码方式。\n位串编码（Bitstring Encoding） # 位串编码的基本思想是将每个自旋轨道映射为一个二进制位：自旋轨道被电子占据时对应位为1，未被占据时为0。这种表示方法不仅直观，还能显著节省存储空间。考虑到电子的自旋特性，为了便于计算（如处理自旋守恒的激发或应用自旋相关的算符），通常将自旋向上（\\(\\alpha\\), \\(\\uparrow\\)）和自旋向下（\\(\\beta\\), \\(\\downarrow\\)）的轨道占据情况分别存储在两个独立的位串中，即 alpha 和 beta。因此，一个完整的Slater行列式在计算机中通常由这一对位串来表示。\n在量子化学中，首先需要定义一套包含 \\(N_{mo}\\) 个空间轨道的基组 \\(\\{\\phi_k\\}_{k=1}^{N_{mo}}\\)。每个空间轨道 \\(\\phi_k\\) 可与 \\(\\alpha\\) 自旋函数结合形成 \\(\\alpha\\) 自旋轨道 \\(\\psi_{k\\alpha}\\)，或与 \\(\\beta\\) 自旋函数结合形成 \\(\\beta\\) 自旋轨道 \\(\\psi_{k\\beta}\\)。由此，\\(\\alpha\\) 和 \\(\\beta\\) 自旋轨道的数量均等于空间轨道数 \\(N_{mo}\\)。在限制性（Restricted）轨道表述中，第 \\(k\\) 个 \\(\\alpha\\) 自旋轨道和第 \\(k\\) 个 \\(\\beta\\) 自旋轨道共享相同的空间函数 \\(\\phi_k\\)。因此，alpha 位串的第 \\(j\\) 位和 beta 位串的第 \\(j\\) 位分别表示第 \\(j+1\\) 个空间轨道的 \\(\\alpha\\) 和 \\(\\beta\\) 自旋的占据情况。\n在非限制性（unrestricted）方法中，\\(\\alpha\\) 和 \\(\\beta\\) 电子可拥有不同的空间轨道，但位串编码的基本原理不变。而在广义（generalized）方法中，自旋轨道是 \\(\\alpha\\) 和 \\(\\beta\\) 自旋函数的线性组合，需采用不同的编码方式。 现代计算机体系结构对固定长度整数类型（如64位无符号整数 uint64_t）的处理尤为高效。因此，当 \\(N_{mo} \\leq 64\\) 时，alpha 和 beta 各可用一个 uint64_t 变量存储。我们可以定义一个简单的结构体来表示行列式的占据情况：\nstruct Determinant { uint64_t alpha; // Alpha自旋轨道占据情况 uint64_t beta; // Beta自旋轨道占据情况 }; 若 \\(N_{mo} \u0026gt; 64\\)，则需使用 uint64_t 数组（如 std::vector\u0026lt;uint64_t\u0026gt;）存储每个位串。例如，对于100个空间轨道，需 \\(\\lceil 100/64 \\rceil = 2\\) 个 uint64_t 整数来分别存储 alpha 和 beta。不过，对于许多中小型体系，64位整数已足够。\n相位因子（Phase Factor）与规范序（Canonical Ordering） # 仅靠轨道占据信息（即位串）无法完全定义一个Slater行列式。由于电子是费米子，交换任意两个电子（即交换产生式算符的顺序）会导致行列式符号反转：\\(a_i^\\dagger a_j^\\dagger = -a_j^\\dagger a_i^\\dagger\\)。因此，产生式算符的排列顺序对行列式的相位因子（通常为+1或-1）至关重要。\n为确保行列式表示的唯一性并正确处理相位，必须采用一个规范序。常见的约定包括：\nAlpha自旋块优先：所有 \\(\\alpha\\) 电子的产生式算符 \\(a_{i\\uparrow}^\\dagger\\) 排列在所有 \\(\\beta\\) 电子的产生式算符 \\(a_{j\\downarrow}^\\dagger\\) 之前。 块内轨道指数升序：在 \\(\\alpha\\) 和 \\(\\beta\\) 自旋块内部，产生式算符按轨道指数 \\(i\\) 或 \\(j\\) 的升序排列。 例如，对于行列式 \\(|J\\rangle = a_{k\\uparrow}^\\dagger a_{i\\uparrow}^\\dagger a_{j\\downarrow}^\\dagger |\\text{vac}\\rangle\\)（其中 \\(i \u0026lt; k\\)），根据规范序应重排为 \\(a_{i\\uparrow}^\\dagger a_{k\\uparrow}^\\dagger a_{j\\downarrow}^\\dagger |\\text{vac}\\rangle\\)。若从原始形式到规范序需奇数次对换，则 \\(|J\\rangle = - |I_{\\text{canonical}}\\rangle\\)。\n在实际计算中，通常以一个已知参考行列式（如Hartree-Fock行列式，相位定义为+1）为起点，通过激发操作生成新行列式。新行列式相对于参考态的相位需精确计算并存储，通常用0（+1）或1（-1）表示。可定义如下结构体：\nstruct DeterminantPhase { uint64_t alpha; uint64_t beta; uint8_t phase; // 0 = +1相位, 1 = -1相位 }; phase 成员存储行列式 \\((\\text{alpha}, \\text{beta})\\) 相对于全局参考态（通常为HF态）的相位，具体计算方法常在辅助函数中实现。\n存储与管理的优势 # 使用 alpha 和 beta 位串对并结合相位因子的存储方式具有以下优势：\n存储紧凑：对于 \\(N_{mo} \\leq 64\\) 的体系，每个行列式的轨道占据信息仅需两个 uint64_t 和一个字节（存储相位），比稀疏矩阵或字符串列表更高效。 快速比较与查找：Determinant 结构体便于实现判等（operator==）和排序（operator\u0026lt;），适用于标准库的有序容器（如 std::set, std::map）或无序容器（如 std::unordered_set, std::unordered_map）。 高效位运算： 电子数统计：通过 __builtin_popcountll 或 std::popcount（C++20） 快速计算位串中1的个数，即 \\(\\alpha\\) 或 \\(\\beta\\) 电子数。 激发操作：单激发、双激发等可通过位运算（如异或 ^、与 \u0026amp;、或 |）高效实现。例如，从轨道 \\(i\\) 到 \\(p\\) 的电子移动可通过 flip_bit(i) 和 flip_bit(p) 操作完成。 差异识别：两个行列式间的差异（激发类型）可通过位串异或操作快速确定。 综上，将Slater行列式表示为 alpha 和 beta 位串对，并显式存储其相对于规范序参考态的相位因子，是计算量子化学中兼顾存储与运算效率的成熟方案。\n","date":"2025-03-17","externalUrl":null,"permalink":"/zh-cn/docs/determinant-based-quantum-chemistrya-programming-practice/1/","section":"Docs","summary":"\u003ch2 class=\"relative group\"\u003e概述 \n    \u003cdiv id=\"%E6%A6%82%E8%BF%B0\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E6%A6%82%E8%BF%B0\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e  在现代量子化学中，行列式驱动的方法，如 \u003cstrong\u003eHartree-Fock (HF)\u003c/strong\u003e 及其后继的 \u003cstrong\u003epost-HF 方法\u003c/strong\u003e，因其在处理多电子系统时展现出计算效率与精度的卓越平衡而占据核心地位。这些方法的理论基础深深植根于 \u003cstrong\u003e二次量子化\u003c/strong\u003e 的表述。二次量子化作为标准量子力学在多体问题中的一种优雅而强大的语言，通过引入 \u003cstrong\u003e产生算符\u003c/strong\u003e \\(a_p^\\dagger\\) 和 \u003cstrong\u003e湮灭算符\u003c/strong\u003e \\(a_p\\)，能够灵活地构造 \u003cstrong\u003eFock 空间\u003c/strong\u003e 中的任意算符，例如哈密顿量和波函数。这种框架不仅精简了复杂量子系统的数学描述，更关键的是，它通过算符之间的 \u003cstrong\u003e反对易关系\u003c/strong\u003e，自动确保了电子作为费米子所要求的波函数反对称性。这一特性在计算化学中至关重要，是行列式驱动方法能够高效实现的关键。\u003c/p\u003e","title":"行列式驱动量子化学方法的编程实践（一）","type":"docs"},{"content":"","date":"2025-03-15","externalUrl":null,"permalink":"/zh-cn/tags/regular-expression/","section":"Tags","summary":"","title":"Regular Expression","type":"tags"},{"content":"","date":"2025-03-15","externalUrl":null,"permalink":"/zh-cn/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025-03-15","externalUrl":null,"permalink":"/zh-cn/utilities/","section":"Utilities","summary":"","title":"Utilities","type":"utilities"},{"content":"","date":"2025-03-15","externalUrl":null,"permalink":"/zh-cn/tags/utility/","section":"Tags","summary":"","title":"Utility","type":"tags"},{"content":" 群的基本定义 # 一个群 (Group) 是由一个非空集合 \\(G\\) 与其上的二元运算（记为\\(\\circ\\)）构成的代数结构，该二元运算满足以下公理：\n结合律（Associativity）：\\(\\forall a, b, c \\in G\\)，有 \\((a \\circ b) \\circ c = a \\circ (b \\circ c).\\)\n单位元（Identity element）：存在一个元素 \\(e \\in G\\)，使得对任意 \\(a \\in G\\)：\\(e \\circ a = a \\circ e = a.\\)\n逆元（Inverse element）：对任意 \\(a \\in G\\)，存在一个元素 \\(a^{-1} \\in G\\)，满足 \\(a \\circ a^{-1} = a^{-1} \\circ a = e.\\)\n按照以上定义，群中的元素在运算 \\(\\circ\\) 下具有封闭性。\n需要注意的是，集合以及其上定义的群通常会共用一个符号 \\(G\\)，但它们是两个不同的数学对象。群上定义了超出集合概念的运算结构，更正式的情况下记为 \\((G, \\circ)\\)。我们称该集合为群\\(G\\)的基础集（underlying set）。\n最常见的两种二元运算为加法和乘法，而群上仅定义有一种运算，据此可以分出加法群（additive group）和乘法群（multiplicative group）。加法群的单位元即为0，任一元素 \\(x\\) 的逆元为 \\(-x\\)；乘法群的单位元为1，任一元素 \\(x\\) 的逆元为 \\(x^{-1}\\)。此外，排列复合、矩阵乘法、对称差、异或 XOR、函数复合等运算都能构成群。\n群的定义并不要求运算满足交换律，据此可以分出阿贝尔群（Abelian group）和非阿贝尔群（non-Abelian group）。群的阶（order）定义为群中元素的个数，记为 \\(|G|\\)。阶为有限的群称为有限群，阶为无穷的群称为无限群。\n基本概念 # 在研究集合时，我们会用到子集，函数和等价关系商等概念。类似的，在研究群时，我们会用到子群，同态和商群等概念。下面分别做介绍。\n子群 # 如果 \\(H\\) 是 \\(G\\) 的一个非空子集，并且 \\(H\\) 在 \\(G\\) 的运算 \\(\\circ\\) 下也构成一个群，那么\\(H\\)称为\\(G\\)的子群（Subgroup）。记作\\(H \\leq G\\)。子群的条件可以简化为以下判定法则：\n封闭性：\\(\\forall a, b \\in H\\)，有 \\(a \\circ b \\in H\\)。 单位元：群 \\(G\\) 的单位元 \\(e\\) 在 \\(H\\) 中。 逆元：\\(\\forall a \\in H\\)，其逆元 \\(a^{-1} \\in H\\)。 若 \\(H \\neq G\\) 且 \\(H \\leq G\\)，则称 \\(H\\) 为 \\(G\\) 的真子群（Proper subgroup），记作 \\(H \u0026lt; G\\)。\n陪集 # 设 \\(H\\) 是群 \\(G\\) 的一个子群，则可以使用 \\(H\\) 将 \\(G\\) 中的元素划分为若干个不相交且彼此具有相同大小的子集，这些子集称为 \\(H\\) 的陪集（coset）。陪集又可以分出左陪集和右陪集，给定 \\(G\\) 的一个元素 \\(g\\)，则有：\n左陪集（Left coset）：\\(gH = {g \\circ h \\mid h \\in H}\\) 右陪集（Right coset）：\\(Hg = {h \\circ g \\mid h \\in H}\\) 容易看出，\\(H\\) 的陪集的阶数与\\(H\\)的阶数相等，\\(H\\) 同时是自身的左陪集和右陪集。左陪集和右陪集的数量相等，称为 \\(H\\) 在 \\(G\\) 中的指数（index），记作 \\([G:H]\\)。\n一个重要的定理是拉格朗日定理：如果 \\(H\\) 是 \\(G\\) 的子群，那么 \\(|G|=|H|[G:H]\\)。这个定理描述了一个群和它的子群的阶数之间的关系。特别地，如果 \\(G\\) 是有限群，那么可以得到推论：只有整除 \\(|G|\\) 的数才可能是子群的阶，因此素数阶群必为循环群； \\(G\\) 中每个元素的阶都会整除群 \\(G\\) 的阶。\n正规子群 # \\(G\\)的所有元素\\(g\\)对应的左陪集和右陪集相等，即\\(gH=Hg\\)时，\\(H\\) 是 \\(G\\) 的正规子群（normal subgroup），记作 \\(H \\triangleleft G\\)。一个等价的定义是，一个正规子群 \\(H\\) 在其所属群 \\(G\\) 的元素 \\(g\\) 的共轭作用下保持不变，即 \\(gHg^{-1} = H\\)。\n商群 # 可以在陪集构成的集合上赋予一个满足群公理的运算，使之成为商群（quotient group）。正式地，若 \\(H\\) 是群 \\(G\\) 的一个正规子群，则可以在 \\(G\\) 的所有左陪集（或右陪集）集合上定义运算 \\((aH) \\circ (bH) = (a \\circ b)H\\)，这样构造出的代数结构称为商群，记作 \\(G/H\\)。\n事实上，能够证明如果这种商群结构能定义成功，则 \\(H\\) 必定是正规子群。左右陪集不等的情况下无法定义出满足群公理的二元运算，但仍可定义类似的结构，形成一个齐性空间。\n之所以称为“商”群，是因为类似于整数除法，8除以2等于4相当于我们把8个对象分组为了各含4个对象的两个子集。而商群类似于我们使用 \\(H\\) 对 \\(G\\)进行了划分。\n中心化子和正规化子 # 在群论中，中心化子和正规化子是两个重要的子群，它们分别描述了群中元素与特定元素或子集的可交换性，以及元素在共轭作用下对子群的影响。\n给定群 \\(G\\) 的一个元素 \\(a\\)，其中心化子（Centralizer） \\(C_G(a)\\) 是 \\(G\\) 中所有与 \\(a\\) 可交换的元素组成的集合： $$ C_{G}(a) = \\{g \\in G \\ | \\ ga = ag\\} $$ \\(C_G(a)\\) 是 \\(G\\) 的一个子群。\n更一般地，对于 \\(G\\) 的一个子集 \\(S\\)（不一定是子群），其中心化子 \\(C_G(S)\\) 是 \\(G\\) 中所有与 \\(S\\) 中每个一个元素都可交换的元素组成的集合： $$ C_G(S) = \\{g \\in G \\ | \\ gs = sg \\ \\forall s \\in S\\} = \\bigcap_{s \\in S} C_G(s) $$ \\(C_G(S)\\) 也是 \\(G\\) 的一个子群。\n群 \\(G\\) 的中心（Center） \\(Z(G)\\) 是 \\(G\\) 中所有与 \\(G\\) 中任意元素都可交换的元素组成的集合，即 \\(Z(G) = C_{G} (G)\\)： $$ Z(G) = \\{z \\in G \\ | \\ zg = gz \\ \\forall g \\in G\\} $$ 中心 \\(Z(G)\\) 是 \\(G\\) 的一个阿贝尔正规子群。\n给定群 \\(G\\) 的一个子群 \\(H\\)，其正规化子 (Normalizer) \\(N_{G}(H)\\) 是 \\(G\\) 中所有满足 \\(g H g^{-1} = H\\) 的元素 \\(g\\) 组成的集合： $$ N_{G}(H) = \\{g \\in G \\ | \\ g H g^{-1} = H\\} $$ 其中 \\(g H g^{-1} = \\{ghg^{-1} \\ | \\ h \\in H\\}\\)。\\(N_{G}(H)\\) 是 \\(G\\) 的一个子群。\n以下是关于正规化子的一些重要性质：\n子群 \\(H\\) 总是其自身正规化子 \\(N_G(H)\\) 的一个正规子群，即 \\(H \\triangleleft N_G(H)\\)。 \\(N_G(H)\\) 是 \\(G\\) 中包含 \\(H\\) 作为正规子群的最大的子群。 一个子群 \\(H\\) 是 \\(G\\) 的正规子群当且仅当 \\(N_G(H) = G\\)。 中心化子与正规化子的关系：对于群 \\(G\\) 的一个子群 \\(H\\)：\n\\(C_G(H)\\) 的元素 \\(g\\) 必须与 \\(H\\) 中的每个元素 \\(h\\) 可交换，即 \\(gh=hg\\)。 \\(N_G(H)\\) 的元素 \\(g\\) 只需要满足共轭作用 \\(gHg^{-1}\\) 保持 \\(H\\) 整体不变，即 \\(gH = Hg\\) （这与陪集的定义相关，也等价于 \\(gHg^{-1} = H\\)）。 显然，如果一个元素 \\(g\\) 与 \\(H\\) 中的每个元素都可交换，那么它必然满足 \\(gHg^{-1} = H\\)。因此，总是有 \\(C_G(H) \\leq N_G(H)\\)。 同时，\\(H\\) 自身也总是其正规化子 \\(N_G(H)\\) 的子群，即 \\(H \\leq N_G(H)\\) （因为对任意 \\(h\u0026rsquo; \\in H\\)，\\(h\u0026rsquo;H(h\u0026rsquo;)^{-1} = H\\) 由于 \\(H\\) 是子群）。 同态与同构 # 设 \\(G\\) 和 \\(H\\) 是两个群, 如果 \\(G\\) 到 \\(H\\) 有一个映射 \\(\\phi\\), 使得 $$ \\phi(ab) = \\phi(a) \\phi(b), \\forall a,b \\in G $$ 那么称 \\(\\phi\\) 是 \\(G\\) 到 \\(H\\) 的一个同态映射，简称为同态。\n如果 \\(\\phi\\) 是单射，则 \\(\\phi\\) 称为单同态；\n如果 \\(\\phi\\) 是满射，则 \\(\\phi\\) 称为满同态；\n如果 \\(\\phi\\) 是双射，则 \\(\\phi\\) 称为同构。此时我们说群 \\(G\\) 和 \\(H\\) 是同构的，记作 \\(G \\cong H\\)。\n显然同态保持群的运算结构，它具有以下基本性质：\n单位元映射到单位元：\\(\\phi(e_G) = e_H\\) 逆元映射到逆元：\\(\\phi(a^{-1}) = \\phi(a)^{-1}\\) 在研究同态时，两个重要概念是：\n核：同态 \\(\\phi: G \\rightarrow H\\) 的核定义为映射到 \\(H\\) 单位元的 \\(G\\) 中所有元素构成的集合： $$ \\ker(\\phi) = {g \\in G \\mid \\phi(g) = e_H} $$\n像：同态 \\(\\phi\\) 的像是 \\(G\\) 中所有元素通过 \\(\\phi\\) 映射得到的 \\(H\\) 的子集： $$ \\text{im}(\\phi) = {\\phi(g) \\mid g \\in G} $$\n可以证明，同态的核是原群的正规子群，而同态的像是目标群的子群。\n第一同构定理：如果 \\(\\phi: G \\rightarrow H\\) 是群同态，则 $$G/\\ker(\\phi) \\cong \\text{im}(\\phi)$$\n这里的概念可能有些复杂，我们举三个例子进行说明：\n1. 从整数群 \\(\\mathbb{Z}\\) 到整数模 \\(n\\) 群 \\(\\mathbb{Z}_n\\) 的映射\n我们构造一个映射： $$ \\phi: \\mathbb{Z} \\rightarrow \\mathbb{Z}_n, \\quad \\phi(k) = k \\operatorname{mod} n $$\n可以快速对该映射的同态性质进行检验，\\(\\forall a,b \\in \\mathbb{Z}\\)， $$ \\phi(a+b) = (a+b) \\operatorname{mod} n $$ $$ \\phi(a) \\oplus \\phi(b) = [(a \\operatorname{mod} n) + (b \\operatorname{mod} n)] \\operatorname{mod} n = (a+b) \\operatorname{mod} n $$ 其中第二个式子利用了模运算的基本性质。可见该映射确实构成了一个群同态。\n我们现在将目光转移到该同态的核与像，显然我们有： $$ \\ker(\\phi) = \\{k \\in \\mathbb{Z} \\,|\\, \\phi(k)=0 \\in \\mathbb{Z}_n \\} = \\{k \\in \\mathbb{Z} \\,|\\, k \\operatorname{mod} n =0 \\} = n\\mathbb{Z} $$ 核由所有能被 \\(n\\) 整除的整数构成，这些元素在映射后都变成 \\(\\mathbb{Z}_n\\) 的单位元“0”。也就是说，这些元素在映射后不可区分。而 $$ \\operatorname{Im}(\\phi) = \\{\\phi(k): k \\in \\mathbb{Z}\\} = \\mathbb{Z}_n $$ 显然这个映射是满射。\n由于 \\(\\phi\\) 是满射，但不是单射，因此它不是一个同构。\n根据第一同构定理， $$ G / \\ker(\\phi) \\cong \\operatorname{Im}(\\phi) \\Longrightarrow \\mathbb{Z} / n \\mathbb{Z} \\cong \\mathbb{Z}_n $$ 也就是说，当我们把 \\(\\mathbb{Z}\\) 按照子群 \\(n\\mathbb{Z}\\) 进行划分后，得到的商群与 \\(\\mathbb{Z}_n\\) 同构。\n2. 从正实数乘法群 \\(\\mathbb{R}^{*}_{+}\\) 到实数加法群 \\(\\mathbb{R}\\) 的对数映射\n我们定义映射： $$ \\phi: \\mathbb{R}^{*}_{+} \\Longrightarrow \\mathbb{R} \\quad \\phi(x) = \\ln(x) $$ 显然我们有： $$ \\phi(x \\times y) = \\ln(xy) = \\ln(x) + \\ln(y) = \\phi(x) + \\phi(y) $$\n因此该映射是一个同态\n$$ \\ker(\\phi) = \\{x \\in \\mathbb{R}^{*}_{+} | \\ln(x) = 0 \\} = \\{ 1 \\} $$\n只有 \\(\\mathbb{R}^{*}_{+}\\) 的单位元1被映射到目标群 \\(\\mathbb{R}\\) 的单位元0。因此 \\(\\phi\\) 是一个单射。\n$$ \\operatorname{Im}(\\phi) = \\{\\ln(x): x \u0026gt; 0\\} = \\mathbb{R} $$\n这也是一个满射。\n因此该映射是一个同构，直观理解就是，乘法对应加法是指数与对数的互逆关系。\n3. 从可逆矩阵群 \\(\\mathrm{GL}_n(\\mathbb{R})\\) 到非零实数乘法群 \\(\\mathbb{R}^*\\) 的行列式映射\n这里 \\(\\mathrm{GL}_n(\\mathbb{R})\\) 是所有 \\(n \\times n\\) 可逆实矩阵的集合，运算是“矩阵乘法”。\n构造映射：\n$$ \\mathrm{GL}_n(\\mathbb{R}) \\rightarrow \\mathbb{R}^* \\quad A \\mapsto \\det(A) $$\n显然对于任意可逆矩阵 \\(A, B\\)，我们有：\n$$ \\det(A B) = \\det(A) \\cdot \\det(B) $$\n因此该映射是一个同态。\n对于核与像，我们有：\n$$ \\ker(\\det) = \\{A \\in \\mathrm{GL}_n(\\mathbb{R}) \\,|\\, \\det(A)=1 \\} $$\n核是所有行列式为1的可逆矩阵构成的集合，通常记为 \\(\\mathrm{SL}_n(\\mathbb{R})\\)。显然该映射不是单射。\n$$ \\operatorname{Im}(\\det) = \\{\\det(A): A \\in \\mathrm{GL}_n(\\mathbb{R})\\} = \\mathbb{R}^* $$\n这是因为给定任意 \\(r \\ne 0\\)，都能找到一个对角矩阵 \\(\\operatorname{diag}(r, 1, 1, \\ldots, 1)\\)，使其行列式值为 \\(r\\)。因此该映射是满射。\n因此该同态不是同构，这体现了尽管行列式把矩阵映射的较为简明，但同一个行列式值的不同矩阵在目标群中被压缩为了同一个点。\n因此，核可以帮助我们发现“映射过程中被合并了哪些元素（信息）”；像可以帮助我们看出“同态覆盖了目标群的哪些部分”。一旦核只有单位元，就意味着没有任何元素被额外折叠，映射是单射。若此时像又是整个目标群，那么两个群就同构。\n示例 # 想象一张在平面上的正方形纸，所有能够将这张正方形纸映射到自身的几何变换（例如旋转、翻折）构成了一个群。我们用 \\(D_4\\) 表示它，常称为“正方形的二面体群”，其基础集中包含八个元素（八种刚体运动），运算则是“连续地做变换”（也就是复合）。为方便描述，我们把顺时针旋转 \\(90^\\circ\\) 记作 \\(r\\)，把绕固定对称轴的一次翻折记作 \\(s\\)。\\(D_4\\) 的八个元素可写为： $$ \\{\\, e,\\; r,\\; r^2,\\; r^3,\\; s,\\; rs,\\; r^2s,\\; r^3s \\}, $$ 其中 \\(e\\) 表示“不动”，即恒等变换；\\(r^k\\) 表示顺时针旋转 \\(90^\\circ\\) 的 \\(k\\) 次方；\\(s\\) 表示一次翻折；\\(r^k s\\) 表示先翻折、再旋转 \\(k\\) 次（或者先旋转 \\(k\\) 次，再翻折，视变换顺序约定而定，但概念上就是“旋转+翻折”的组合）。\n在 \\(D_4\\) 里，任何三个变换复合起来都可以通过结合律减少成两个变换的复合，不会有歧义；不动元 \\(e\\) 对任何元素都满足 \\(e \\circ g = g \\circ e = g\\)；每个变换都有“逆变换”，例如 \\(r\\) 的逆元是 \\(r^3\\)，翻折 \\(s\\) 的逆元就是它本身 \\(s\\)。所以 \\(D_4\\) 确实是一个群。\n再来看子群。\\(D_4\\) 里有一个重要子群，即只做旋转的那部分 \\(\\langle r\\rangle = \\{e,\\, r,\\, r^2,\\, r^3\\}\\)。它的元素个数是4，满足前面提到的三条子群判定标准，故 \\(\\langle r\\rangle\\) 的确是 \\(D_4\\) 的子群。作为子群，\\(\\langle r\\rangle\\) 在全群中的单位元还是同一个 \\(e\\)，逆元也沿用 \\(D_4\\) 的“逆变换”概念。\\(\\langle r\\rangle\\) 本身又是一个循环群。\n如果拿 \\(\\langle r\\rangle\\) 去划分陪集，可以将 \\(D_4\\) 的八个元素划分为两个大小相等的不相交子集：\\(\\langle r\\rangle\\) 自身（它既是一个左陪集，也是一个右陪集），以及 \\(s\\langle r\\rangle = \\{s,\\, rs,\\, r^2s,\\, r^3s\\}\\)。我们可以感受一下这一划分：任意元素若属于第一个子集（只做旋转），或第二个子集（带有翻折），彼此就不会有重叠，也恰好把群里的元素“一分为二”。这说明了指数 \\([D_4 : \\langle r\\rangle]\\) 是2，从而也能验证拉格朗日定理里的 \\(|D_4| = 8\\) 与 \\(|\\langle r\\rangle|=4\\) 的关系：\\(8 = 4 \\times 2\\)。\n继续观察会发现 \\(\\langle r\\rangle\\) 还是 \\(D_4\\) 的一个正规子群，即对每一个 \\(g \\in D_4\\)，都有 \\(g \\langle r\\rangle g^{-1} = \\langle r\\rangle\\)。直观来说，对称地“转一圈”再“转回来”，或者“翻折一下”再“翻回来”，都不会跳出那个纯粹旋转的子群。因为 \\(\\langle r\\rangle\\) 是正规子群，我们可以在它的陪集上赋予群运算，从而形成商群 \\(D_4 / \\langle r\\rangle\\)。这个商群只有两个元素：一个是 \\(\\langle r\\rangle\\) 自身，另一个是 \\(s \\langle r\\rangle\\)。运算定义如下：\\((a\\langle r\\rangle) \\circ (b\\langle r\\rangle) = (a \\circ b)\\langle r\\rangle\\)。读起来可能有点抽象，其实可以把这两个陪集理解成“是否带有翻折”的两种对称类型，整个结构恰好和只有两个元素的群（记为 \\(\\mathbb{Z}_2\\) 或者 \\({0,1}\\)）相似，也就是我们在抽象上把“纯旋转”和“带翻折”当作两个宏观的等价类。\n最后定义一个映射 \\(\\phi: D_4 \\to \\{1, -1\\}\\)（其中 \\(\\{1,-1\\}\\) 可以理解成一个两元素的乘法群），规定凡是“纯旋转”的元素都映射到 \\(1\\)，凡是“带翻折”的元素都映射到 \\(-1\\)。这样便保持了群结构：任何两个纯旋转复合仍是纯旋转，对应 \\(1 \\times 1 = 1\\)；任何翻折与旋转的组合出来还是翻折，对应 \\(1 \\times -1 = -1\\)；两个翻折复合回到纯旋转，对应 \\((-1) \\times (-1) = 1\\)。这映射 \\(\\phi\\) 就是一个群同态。它的核正是 \\(\\langle r\\rangle\\)，对应映到 \\(1\\) 的所有元素；它的像是 \\(\\{1, -1\\}\\)，即整个目标群。按照第一同构定理，我们得到 \\(D_4 / \\langle r\\rangle \\cong \\{1, -1\\}\\)，呼应了上面关于商群的认识。\n","date":"2025-03-15","externalUrl":null,"permalink":"/zh-cn/docs/summary-of-group-theory/group1/","section":"Docs","summary":"\u003ch2 class=\"relative group\"\u003e群的基本定义 \n    \u003cdiv id=\"%E7%BE%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E7%BE%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e  一个\u003cstrong\u003e群\u003c/strong\u003e (Group) 是由一个非空集合 \\(G\\) 与其上的二元运算（记为\\(\\circ\\)）构成的代数结构，该二元运算满足以下公理：\u003c/p\u003e","title":"群论：基本概念","type":"docs"},{"content":" RRKM Theory is a Microcanonical Version of TST # RRKM Theory (Rice–Ramsperger–Kassel–Marcus Theory) is indeed often considered a microcanonical extension of Transition State Theory (TST). Both theories share foundational assumptions and are used to describe reaction rates, but they operate within different statistical frameworks:\nTST typically operates within a canonical (constant temperature) ensemble, assuming that the system is in thermal equilibrium with a heat bath. RRKM Theory extends TST to a microcanonical (constant energy) ensemble, allowing for the calculation of unimolecular reaction rates as a function of energy. Common Assumptions in RRKM and TST # Born-Oppenheimer (BO) Approximation: Both theories assume the BO approximation, which separates electronic and nuclear motions due to the large difference in their masses. This allows the potential energy surface (PES) to be treated independently of electronic transitions during the reaction.\nEquilibrium Between Reactants and Activated Complex: Both theories assume that there is a rapid and reversible equilibrium between reactants and the activated (transition) complex. This implies that the population of the activated complex is determined by the equilibrium distribution.\nNo Recrossing of the Transition State: Both theories assume that once the system crosses the transition state, it proceeds to form products without reverting to reactants. This idealization means that the transmission coefficient (κ) is assumed to be close to 1, indicating minimal or no recrossing.\nSeparable Reaction Paths: The reaction path is assumed to be separable from the other degrees of freedom, allowing the reaction coordinate to be treated independently. This simplifies the analysis by focusing on the primary pathway of the reaction.\nLimitations # Given the assumptions outlined above, RRKM Theory and TST have several limitations that constrain their applicability:\nSingle Reaction Surface:\nLimitation: These theories are only applicable to reactions that proceed along a single, well-defined potential energy surface (PES) without significant contributions from multiple pathways or surfaces. Implication: Reactions involving multiple competing pathways or surface crossings cannot be accurately described using RRKM or TST. Long Transition State Lifetimes Relative to IVR:\nLimitation: Both theories require that the lifetime of the transition state is much longer than the timescale of Intramolecular Vibrational Redistribution (IVR). Implication: If IVR is not sufficiently rapid, the energy within the activated complex may not be uniformly redistributed, violating the statistical energy distribution assumption and leading to inaccurate rate predictions. Transmission Coefficient Near 1:\nLimitation: The assumption that the transmission coefficient (κ) is close to 1 implies negligible recrossing of the transition state. Implication: In systems where recrossing is significant, the transmission coefficient deviates from 1, rendering the theories\u0026rsquo; rate predictions unreliable. Inapplicability to Barrierless Reactions:\nLimitation: Both RRKM and TST rely on the existence of a well-defined transition state with an associated energy barrier. Implication: Barrierless reactions, which proceed without a significant energy barrier or distinct transition state, cannot be accurately described by these theories. Alternative models, such as direct dynamics simulations, are required for such reactions. Assumption of Separable Reaction Paths:\nLimitation: The assumption that the reaction coordinate is separable from other degrees of freedom may not hold in systems where there is strong coupling between the reaction coordinate and other vibrational modes. Implication: In such cases, the energy distribution cannot be treated independently, leading to potential inaccuracies in rate calculations. Neglect of Quantum Effects:\nLimitation: Both theories primarily treat nuclear motion classically and may not account for quantum mechanical effects such as tunneling, especially significant in reactions involving light atoms like hydrogen. Implication: For reactions where quantum effects play a crucial role, RRKM and TST may underestimate or misrepresent the actual reaction rates. Summary # RRKM Theory extends TST to a microcanonical framework, maintaining similar foundational assumptions. Both theories assume the Born-Oppenheimer approximation, equilibrium between reactants and the activated complex, no recrossing, and separable reaction paths. Limitations: Applicable only to single reaction surfaces. Require that the transition state lifetime is much longer than IVR. Assume the transmission coefficient is near 1. Not suitable for barrierless reactions. Depend on the separability of reaction paths and often neglect quantum effects. ","date":"25 October 2024","externalUrl":null,"permalink":"/docs/tst-and-rrkm-/test/","section":"Docs","summary":"\u003ch3 class=\"relative group\"\u003e\u003cstrong\u003eRRKM Theory is a Microcanonical Version of TST\u003c/strong\u003e \n    \u003cdiv id=\"rrkm-theory-is-a-microcanonical-version-of-tst\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#rrkm-theory-is-a-microcanonical-version-of-tst\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eRRKM Theory (Rice–Ramsperger–Kassel–Marcus Theory)\u003c/strong\u003e is indeed often considered a microcanonical extension of \u003cstrong\u003eTransition State Theory (TST)\u003c/strong\u003e. Both theories share foundational assumptions and are used to describe reaction rates, but they operate within different statistical frameworks:\u003c/p\u003e","title":"Assumptions and Limitations in RRKM and TST","type":"docs"},{"content":" 这篇文章也用于评估KaTeX的渲染性能。 原文为英文，该文本由自然语言处理程序翻译得到。 引言 # 考虑一个一般的基元反应： $$ a \\mathrm{A} + b \\mathrm{B} \\rightarrow c \\mathrm{C} + d \\mathrm{D} $$ 根据惯例，为了使反应从左到右进行时速率为正，我们对生成物选择正的导数，对反应物选择负的导数。微分速率方程可以写为： $$ \\frac{1}{c} \\frac{\\mathrm{d}[\\mathrm{C}]}{\\mathrm{d}t} = \\frac{1}{d} \\frac{\\mathrm{d}[\\mathrm{D}]}{\\mathrm{d}t} = -\\frac{1}{a} \\frac{\\mathrm{d}[\\mathrm{A}]}{\\mathrm{d}t} = -\\frac{1}{b} \\frac{\\mathrm{d}[\\mathrm{B}]}{\\mathrm{d}t} = k [\\mathrm{A}]^{a} [\\mathrm{B}]^b $$ 反应的级数是速率方程中反应物的指数之和。总反应级数是每个反应物对应的反应级数之和。速率常数 \\(k\\) 与温度有关，但与反应物的浓度无关。\n最常见的基元反应是零级、一级和二级反应，而三级及以上的反应很少见。以下将推导这些反应的积分速率方程。\n零级反应 # 对于零级反应，速率方程为： $$ \\frac{\\mathrm{d}[\\mathrm{A}]}{\\mathrm{d}t} = -k $$ 对这个方程进行积分得到： $$ [\\mathrm{A}] = -kt + [\\mathrm{A}(0)] $$ 这个方程描述了反应物浓度随时间的变化。\n一级反应 # 对于一级反应，速率方程为： $$ \\frac{\\mathrm{d}[\\mathrm{A}]}{\\mathrm{d}t} = -k[\\mathrm{A}] $$ 对这个方程进行积分得到： $$ \\ln [\\mathrm{A}] = -kt + \\ln [\\mathrm{A}(0)] $$ 这个方程描述了反应物浓度随时间的变化。\n二级反应 # \\(2 \\mathrm{A} \\rightarrow \\mathrm{products}\\) # 对于反应 \\(2 \\mathrm{A} \\rightarrow \\mathrm{products}\\)，微分速率方程为： $$ \\frac{1}{2} \\frac{\\mathrm{d}[\\mathrm{A}]}{\\mathrm{d}t} = k[\\mathrm{A}]^2 $$ 设 \\(x\\) 表示反应的进度，即 \\(\\mathrm{A}\\) 的浓度变化。则有： $$ [\\mathrm{A}] = [\\mathrm{A}(0)] - 2x $$ 代入速率方程得到： $$ \\frac{\\mathrm{d}x}{\\mathrm{d}t} = k ([\\mathrm{A}(0)] - 2x)^2 $$ 分离变量： $$ \\int \\frac{\\mathrm{d}x}{([\\mathrm{A}(0)] - 2x)^2} = k \\int \\mathrm{d}t $$ 对两边积分： $$ -\\frac{1}{2[\\mathrm{A}]} + \\frac{1}{2[\\mathrm{A}(0)]} = kt $$ 重新整理： $$ \\frac{1}{[\\mathrm{A}]} = 2kt + \\frac{1}{[\\mathrm{A}(0)]} $$ 这个方程描述了反应物浓度随时间的变化。\n\\(\\mathrm{A} + \\mathrm{B} \\rightarrow \\mathrm{products}\\) # 对于反应 \\(\\mathrm{A} + \\mathrm{B} \\rightarrow \\mathrm{products}\\)，微分速率方程为： $$ -\\frac{\\mathrm{d}[\\mathrm{A}]}{\\mathrm{d}t} = -\\frac{\\mathrm{d}[\\mathrm{B}]}{\\mathrm{d}t} = k[\\mathrm{A}][\\mathrm{B}] $$ 设 \\(x\\) 表示反应的进度。则有： $$ [\\mathrm{A}] = [\\mathrm{A}(0)] - x, \\quad [\\mathrm{B}] = [\\mathrm{B}(0)] - x $$ 代入速率方程： $$ \\frac{\\mathrm{d}x}{\\mathrm{d}t} = k([\\mathrm{A}(0)] - x)([\\mathrm{B}(0)] - x) $$ 分离变量： $$ \\int \\frac{\\mathrm{d}x}{([\\mathrm{A}(0)] - x)([\\mathrm{B}(0)] - x)} = k \\int \\mathrm{d}t $$ 使用部分分数分解： $$ \\frac{1}{([\\mathrm{A}(0)] - x)([\\mathrm{B}(0)] - x)} = \\frac{1}{[\\mathrm{A}(0)] - [\\mathrm{B}(0)]} \\left(\\frac{1}{[\\mathrm{B}(0)] - x} - \\frac{1}{[\\mathrm{A}(0)] - x}\\right) $$ 对两边积分： $$ \\frac{1}{[\\mathrm{A}(0)] - [\\mathrm{B}(0)]} \\ln \\frac{[\\mathrm{A}][\\mathrm{B}(0)]}{[\\mathrm{A}(0)][\\mathrm{B}]} = kt $$ 这个方程描述了两个反应物的浓度随时间的变化。\n三级反应 # \\(\\text{A}+\\text{B}+\\text{C} \\rightarrow \\text{products}\\) # 对于含有三个不同反应物的三级反应，微分速率方程为： $$ -\\frac{d[\\text{A}]}{dt} = -\\frac{d[\\text{B}]}{dt} = -\\frac{d[\\text{C}]}{dt} = k[\\text{A}][\\text{B}][\\text{C}] $$\n设 \\(x\\) 表示反应的进度。则有： $$ [\\text{A}] = [\\text{A}(0)] - x, \\quad [\\text{B}] = [\\text{B}(0)] - x, \\quad [\\text{C}] = [\\text{C}(0)] - x $$\n代入速率方程： $$ \\frac{dx}{dt} = k([\\text{A}(0)] - x)([\\text{B}(0)] - x)([\\text{C}(0)] - x) $$\n分离变量：\n$$ \\int \\frac{dx}{([\\text{A}(0)] - x)([\\text{B}(0)] - x)([\\text{C}(0)] - x)} = k \\int dt $$\n使用部分分数分解：\n$$ \\frac{1}{([\\text{A}(0)] - x)([\\text{B}(0)] - x)([\\text{C}(0)] - x)} = \\frac{A}{[\\text{A}(0)] - x} + \\frac{B}{[\\text{B}(0)] - x} + \\frac{C}{[\\text{C}(0)] - x} $$\n两边乘以 \\(([\\text{A}(0)] - x)([\\text{B}(0)] - x)([\\text{C}(0)] - x)\\) 并展开，通过匹配各项确定系数 \\(A\\)、\\(B\\) 和 \\(C\\)。解得：\n$$ A = \\frac{1}{([\\text{B}(0)] - [\\text{A}(0)])([\\text{C}(0)] - [\\text{A}(0)])}, \\quad B = \\frac{1}{([\\text{A}(0)] - [\\text{B}(0)])([\\text{C}(0)] - [\\text{B}(0)])}, \\quad C = \\frac{1}{([\\text{A}(0)] - [\\text{C}(0)])([\\text{B}(0)] - [\\text{C}(0)])} $$\n因此，积分变为\n$$ A \\int \\frac{dx}{[\\text{A}(0)] - x} + B \\int \\frac{dx}{[\\text{B}(0)] - x} + C \\int \\frac{dx}{[\\text{C}(0)] - x} = kt + \\text{常数} $$\n对两边积分并合并常数，得到积分速率方程：\n$$ \\frac{1}{([\\text{B}(0)] - [\\text{A}(0)])([\\text{C}(0)] - [\\text{A}(0)])} \\ln\\left(\\frac{[\\text{B}][\\text{C}][\\text{A}(0)]}{[\\text{B}(0)][\\text{C}(0)][\\text{A}]}\\right) + \\frac{1}{([\\text{A}(0)] - [\\text{B}(0)])([\\text{C}(0)] - [\\text{B}(0)])} \\ln\\left(\\frac{[\\text{A}][\\text{C}][\\text{B}(0)]}{[\\text{A}(0)][\\text{C}(0)][\\text{B}]}\\right) + \\frac{1}{([\\text{A}(0)] - [\\text{C}(0)])([\\text{B}(0)] - [\\text{C}(0)])} \\ln\\left(\\frac{[\\text{A}][\\text{B}][\\text{C}(0)]}{[\\text{A}(0)][\\text{B}(0)][\\text{C}]}\\right) = kt $$\n\\(2 \\text{A} + \\text{B} \\rightarrow \\text{products}\\) # 从微分速率方程开始：\n$$ \\frac{1}{2} \\frac{d[\\text{A}]}{dt} = -\\frac{d[\\text{B}]}{dt} = k[\\text{A}]^2[\\text{B}] $$\n设 \\(x\\) 表示反应的进度，\\(x\\) 为 \\(\\text{B}\\) 的浓度变化。则有\n$$ [\\text{A}] = [\\text{A}(0)] - 2x, \\quad [\\text{B}] = [\\text{B}(0)] - x $$\n代入速率方程得到\n$$ \\frac{dx}{dt} = k ([\\text{A}(0)] - 2x)^2 ([\\text{B}(0)] - x) $$\n分离变量：\n$$ \\int \\frac{dx}{([\\text{A}(0)] - 2x)^2 ([\\text{B}(0)] - x)} = k \\int dt $$\n使用部分分数分解，\n$$ \\frac{1}{([\\text{A}(0)] - 2x)^2 ([\\text{B}(0)] - x)} = \\frac{A}{[\\text{A}(0)] - 2x} + \\frac{B}{([\\text{A}(0)] - 2x)^2} + \\frac{C}{[\\text{B}(0)] - x} $$\n两边乘以 \\(([\\text{A}(0)] - 2x)^2 ([\\text{B}(0)] - x)\\) 并展开，通过匹配各项确定系数 \\(A\\)、\\(B\\) 和 \\(C\\)。解得\n$$ A = -\\frac{2}{\\left( [\\text{A}(0)] - 2[\\text{B}(0)] \\right)^2}, \\quad B = -\\frac{2}{[\\text{A}(0)] - 2[\\text{B}(0)]}, \\quad C = \\frac{1}{\\left( [\\text{A}(0)] - 2[\\text{B}(0)] \\right)^2} $$\n因此，积分变为\n$$ \\int \\frac{dx}{([\\text{A}(0)] - 2x)^2 ([\\text{B}(0)] - x)} = -\\frac{1}{\\left( [\\text{A}(0)] - 2[\\text{B}(0)] \\right)} \\left( \\frac{1}{[\\text{A}]} - \\frac{1}{[\\text{A}(0)]} \\right) - \\frac{1}{\\left( [\\text{A}(0)] - 2[\\text{B}(0)] \\right)^2} \\ln \\frac{[\\text{A}][\\text{B}(0)]}{[\\text{A}(0)][\\text{B}]} $$\n对两边积分并合并常数，得到积分速率方程：\n$$ \\frac{1}{[\\text{A}(0)] - 2[\\text{B}(0)]} \\left( \\frac{1}{[\\text{A}(0)]} - \\frac{1}{[\\text{A}]} \\right) + \\frac{1}{\\left( [\\text{A}(0)] - 2[\\text{B}(0)] \\right)^2} \\ln \\frac{[\\text{A}][\\text{B}(0)]}{[\\text{A}(0)][\\text{B}]} = kt $$\n","date":"2024-10-25","externalUrl":null,"permalink":"/zh-cn/docs/differential-and-integral-rate-laws-for-common-types-of-reactions/test/","section":"Docs","summary":"\u003cdiv\n  \n    class=\"flex px-4 py-3 rounded-md bg-primary-100 dark:bg-primary-900\"\n  \u003e\n\n  \u003cspan\n    \n      class=\"text-primary-400 ltr:pr-3 rtl:pl-3 flex items-center\"\n    \u003e\n\n    \n\n  \u003cspan class=\"relative block icon\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e\u003cpath fill=\"currentColor\" d=\"M506.3 417l-213.3-364c-16.33-28-57.54-28-73.98 0l-213.2 364C-10.59 444.9 9.849 480 42.74 480h426.6C502.1 480 522.6 445 506.3 417zM232 168c0-13.25 10.75-24 24-24S280 154.8 280 168v128c0 13.25-10.75 24-23.1 24S232 309.3 232 296V168zM256 416c-17.36 0-31.44-14.08-31.44-31.44c0-17.36 14.07-31.44 31.44-31.44s31.44 14.08 31.44 31.44C287.4 401.9 273.4 416 256 416z\"/\u003e\u003c/svg\u003e\n\n  \u003c/span\u003e\n\n\n  \u003c/span\u003e\n\n  \u003cspan\n    \n      class=\"dark:text-neutral-300\"\n    \u003e这篇文章也用于评估KaTeX的渲染性能。\u003c/span\u003e\n\u003c/div\u003e\n\n\n  \n\n\n\n\u003cdiv\n  \n    class=\"flex px-4 py-3 rounded-md bg-primary-100 dark:bg-primary-900\"\n  \u003e\n\n  \u003cspan\n    \n      class=\"text-primary-400 ltr:pr-3 rtl:pl-3 flex items-center\"\n    \u003e\n\n    \n\n  \u003cspan class=\"relative block icon\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e\u003cpath fill=\"currentColor\" d=\"M506.3 417l-213.3-364c-16.33-28-57.54-28-73.98 0l-213.2 364C-10.59 444.9 9.849 480 42.74 480h426.6C502.1 480 522.6 445 506.3 417zM232 168c0-13.25 10.75-24 24-24S280 154.8 280 168v128c0 13.25-10.75 24-23.1 24S232 309.3 232 296V168zM256 416c-17.36 0-31.44-14.08-31.44-31.44c0-17.36 14.07-31.44 31.44-31.44s31.44 14.08 31.44 31.44C287.4 401.9 273.4 416 256 416z\"/\u003e\u003c/svg\u003e\n\n  \u003c/span\u003e\n\n\n  \u003c/span\u003e\n\n  \u003cspan\n    \n      class=\"dark:text-neutral-300\"\n    \u003e原文为英文，该文本由自然语言处理程序翻译得到。\u003c/span\u003e\n\u003c/div\u003e\n\n\n\n\u003ch2 class=\"relative group\"\u003e引言 \n    \u003cdiv id=\"%E5%BC%95%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%BC%95%E8%A8%80\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e考虑一个一般的基元反应：\n$$\na \\mathrm{A} + b \\mathrm{B} \\rightarrow c \\mathrm{C} + d \\mathrm{D}\n$$\n根据惯例，为了使反应从左到右进行时速率为正，我们对生成物选择正的导数，对反应物选择负的导数。微分速率方程可以写为：\n$$\n\\frac{1}{c} \\frac{\\mathrm{d}[\\mathrm{C}]}{\\mathrm{d}t} = \\frac{1}{d} \\frac{\\mathrm{d}[\\mathrm{D}]}{\\mathrm{d}t} = -\\frac{1}{a} \\frac{\\mathrm{d}[\\mathrm{A}]}{\\mathrm{d}t} = -\\frac{1}{b} \\frac{\\mathrm{d}[\\mathrm{B}]}{\\mathrm{d}t} = k [\\mathrm{A}]^{a} [\\mathrm{B}]^b\n$$\n反应的级数是速率方程中反应物的指数之和。总反应级数是每个反应物对应的反应级数之和。速率常数 \\(k\\) 与温度有关，但与反应物的浓度无关。\u003c/p\u003e","title":"常见反应类型的微分速率法则与积分速率法则","type":"docs"},{"content":"","externalUrl":null,"permalink":"/zh-cn/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/zh-cn/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]