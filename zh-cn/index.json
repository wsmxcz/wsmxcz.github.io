[{"content":" 匹配规则 # 在编辑Markdown时，特别是在页面渲染应用场景下，数学公式往往需要特定的转义定界符，这里我列出了一些常用定界符的正则表达式，以实现快速的批量匹配：\n行内公式 \\(...\\): (?\u0026lt;!\\\\)\\\\\\((.*?)(?\u0026lt;!\\\\)\\\\\\) \\\\(...\\\\): (?\u0026lt;!\\\\)\\\\\\\\\\((.*?)(?\u0026lt;!\\\\)\\\\\\\\\\) $...$: (?\u0026lt;!\\$)\\$(?!\\$)(.*?)(?\u0026lt;!\\$)\\$(?!\\$) 行间公式 \\[...\\]: (?\u0026lt;!\\\\)\\\\\\[\\n(.*?)\\n(?\u0026lt;!\\\\)\\\\\\] \\\\[...\\\\]: (?\u0026lt;!\\\\)\\\\\\\\\\[\\n(.*?)\\n(?\u0026lt;!\\\\)\\\\\\\\\\] $$...$$: (?\u0026lt;!\\$)\\$\\$(?!\\$)\\n(.*?)\\n(?\u0026lt;!\\$)\\$\\$(?!\\$) \\begin{equation}...\\end{equation} (?\u0026lt;!\\\\)\\\\begin{equation}\\n(.*?)\\n(?\u0026lt;!\\\\)\\\\end{equation} 这里使用负向回顾断言（(?\u0026lt;!\\\\)、(?\u0026lt;!\\$)）和负向前瞻断言（(?!\\\\\\$、(?!\\$）来避免分隔符之间的冲突（例如，$...$ 与 $$...$$）。对于行间公式，加入了换行符\\n，如果不需要可以删去。\n替换规则 # 匹配完成后常常需要替换，使用基本的逻辑即可，列出如下：\n\\(...\\): \\\\\\($1\\\\\\) \\\\(...\\\\): \\\\\\\\($1\\\\\\\\) $...$: $$$1$$ \\[...\\]: \\\\[\\n$\\n1\\\\] \\\\[...\\\\]: \\\\\\\\[\\n$1\\n\\\\\\\\] $$...$$: $$$$\\n$1\\n$$$$ \\begin{equation}...\\end{equation} \\begin{equation}\\n$1\\n\\end{equation} ","date":"2025-03-15","externalUrl":null,"permalink":"/zh-cn/utilities/unifying-multi-format-mathematical-formula-delimiters-via-regular-expressions/test/","section":"Utilities","summary":"\u003ch3 class=\"relative group\"\u003e匹配规则 \n    \u003cdiv id=\"%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cp\u003e在编辑Markdown时，特别是在页面渲染应用场景下，数学公式往往需要特定的转义定界符，这里我列出了一些常用定界符的正则表达式，以实现快速的批量匹配：\u003c/p\u003e","title":"基于正则表达式统一匹配替换多格式数学公式定界符","type":"utilities"},{"content":"My name is Zheng (Alex) Che. I earned a Bachelor\u0026rsquo;s degree from the Cuiying Honors College of Lanzhou University. I\u0026rsquo;m currently pursuing a Master\u0026rsquo;s degree at the University of Science and Technology of China.\nMy research interests center on employing neural networks, quantum computing, and other advanced computational methods to explore quantum many-body systems, particularly focusing on the structure and properties of electronic systems.\nIn addition, I have a keen interest in fundamental and cutting-edge topics in mathematics, physics, and computer science.\n","date":"2025-03-19","externalUrl":null,"permalink":"/zh-cn/aboutme/","section":"如我所见","summary":"\u003cp\u003eMy name is Zheng (Alex) Che. I earned a Bachelor\u0026rsquo;s degree from the Cuiying Honors College of Lanzhou University. I\u0026rsquo;m currently pursuing a Master\u0026rsquo;s degree at the University of Science and Technology of China.\u003c/p\u003e","title":"关于我","type":"page"},{"content":"","date":"2025-03-19","externalUrl":null,"permalink":"/zh-cn/","section":"如我所见","summary":"","title":"如我所见","type":"page"},{"content":"","date":"2025-03-17","externalUrl":null,"permalink":"/zh-cn/docs/","section":"Docs","summary":"","title":"Docs","type":"docs"},{"content":"","date":"2025-03-17","externalUrl":null,"permalink":"/zh-cn/series/group-theory/","section":"Series","summary":"","title":"Group Theory","type":"series"},{"content":" 概述 # 对于无结构的搜索问题，Grover 算法相较于经典算法从理论上提供了平方根级别的加速。\n无结构搜索问题 # 无结构搜索问题可以形式化为：\n经典搜索问题：\nInput: 问题的规模 \\(n \\in \\mathbb{N} \\)，一个能够执行函数 \\(f: \\{0,1\\}^n \\rightarrow \\{0,1\\}\\) 的 Oracle.\nOutput: 一个满足 \\(f(\\mathbf{x})=1\\) 的string \\(\\mathbf{x}\\).\n这个问题可以有一些变体，例如我们可以先验设定问题解的数量（不存在解，只有唯一解，存在多个解等）。\n限制函数的输入域为 \\(\\mathbb{Z}_{2^n}\\) 并不会缩小或特化问题适用的范围，但可以帮助我们简化问题。对于任意的 \\(N \\in \\mathbb{Z}_{2^n}\\) 和任意函数 \\(f: \\mathbb{Z}_N \\rightarrow \\{0, 1\\}\\)，我们可以将 \\(\\mathbb{Z}_N\\) 嵌入到 \\(\\mathbb{Z}_{2^n}\\,|\\, n = [\\log_2 N]\\) 中，并规定超出范围的输入返回0。\n很容易想象到，在经典计算机上求解此问题，在最坏的情形下，需要调用Oracle \\(2^n\\) 次（遍历整个问题空间，理论上界）。但量子计算机上执行的 Grover 算法能够提供平方根级的加速，将调用次数的理论上界减少至 \\(2^{n-1}\\)。\nGrover 算法 # 我们此处设定问题解的数量是有限的。Grover算法需要两个寄存器：寄存器1包含 \\(n\\) 个量子比特，用于存储数据信息；寄存器2包含一个量子比特，用以存储条件函数 \\(f(x)\\) 的值。首先将寄存器1中的量子比特制备至最大叠加态（利用 \\(H^{\\otimes n}\\)），寄存器2制备到 \\(\\ket{-}\\) 态。因此，整个系统初始处于量子态： $$ \\ket{\\Phi_0} = \\frac{1}{\\sqrt{N}} \\sum_{\\mathbf{x}\\in \\{0,1\\}^n} \\ket{\\mathbf{x}} \\otimes \\ket{-} $$\nGrover算法使用一个酉算符 \\(U_f\\) 实现搜索算法中的函数 \\(f\\)，定义为： $$ U_f : \\mathcal{H}^n \\otimes \\mathcal{H}^1 \\rightarrow \\mathcal{H}^n \\otimes \\mathcal{H}^1 $$ $$ U_f \\ket{\\mathbf{x}}\\ket{y} = \\ket{\\mathbf{x}} \\ket{f(\\mathbf{x}) \\oplus y} = \\ket{\\mathbf{x}} X^{f(\\mathbf{x})} \\ket{y} $$\n基于此，我们可以定义无结构搜索问题的量子版本：\n量子搜索问题：\nInput: 问题的规模 \\(n \\in \\mathbb{N} \\)，一个能够实现上述 \\(U_f\\) 的 Oracle。 \\(M=|f^{-1}(1)|, M\u0026gt;0\\)\nOutput: 一个满足 \\(f(\\mathbf{x})=1\\) 的string \\(\\mathbf{x}\\).\n我们下面说明，直接测量寄存器1即可得到结果。寄存器1的量子态可以写为： $$ \\ket{s} = \\frac{1}{\\sqrt{N}} \\sum_{\\mathbf{x}\\in \\{0,1\\}^n} \\ket{\\mathbf{x}} $$\n我们设定： $$ \\ket{s_0} = \\frac{1}{\\sqrt{N}} \\sum_{\\mathbf{x}\\in \\{0,1\\}^n, f(\\mathbf{x})=0} \\ket{\\mathbf{x}} $$ $$ \\ket{s_1} = \\frac{1}{\\sqrt{N}} \\sum_{\\mathbf{x}\\in \\{0,1\\}^n, f(\\mathbf{x})=1} \\ket{\\mathbf{x}} $$ $$ \\theta = \\arcsin{\\sqrt{M/N}} $$\n那么我们可以将寄存器1的量子态写为： $$ \\ket{s} = \\sqrt{\\frac{N-M}{N}} \\ket{s_0} + \\sqrt{\\frac{M}{N}} \\ket{s_1} = \\cos{\\theta}\\ket{s_0} + \\sin{\\theta} \\ket{s_1} $$\n在 \\(\\mathcal{H}^n\\) 的计算基上测量 \\(\\ket{s}\\)，就可以得到获得满足 \\(f(\\mathbf{x})=1\\) 的 \\(\\mathbf{x}\\) 的概率： $$ p = \\sin^2{\\theta} = \\frac{M}{N} $$ 这代表了正确得到搜索问题解的概率，相比经典策略并没有提供任何优势。\n为了找出可能存在的量子优势，我们需要一种称为“振幅放大”的技术，这可以提高目标态 \\(\\ket{s_1}\\) 的振幅从而增大获得正确答案的概率。振幅放大操作需要利用一种称为 Grover 迭代器的酉算符 \\(G\\)，定义为： $$ G (\\cos{\\alpha}\\ket{s_0} + \\sin{\\alpha} \\ket{s_1}) = \\cos{(\\alpha+2\\theta)}\\ket{s_0} + \\sin{(\\alpha + 2 \\theta)} \\ket{s_1}, \\forall \\alpha \\in \\mathbb{R} $$\n对寄存器1施加 \\(k \\in \\mathbb{N_0}\\) 次Grover迭代器，就可以得到： $$ G^k \\ket{s} = \\cos{(2k+1)\\theta} \\ket{s_0} + \\sin{(2k+1)\\theta} \\ket{s_1} $$\n至此，我们可以描述出 Grover 算法的整个流程（只考虑寄存器1）。首先，我们制备出初始的最大叠加态 \\(\\ket{s}\\)，然后对 \\(\\ket{s}\\) 施加 \\(k\\) 次 Grover迭代器，最后在 \\(\\mathcal{H}^n\\) 的计算基上测量 \\(\\ket{s}\\) 得到结果。Grover迭代器的施加次数 \\(k\\) 取决于 \\(2(k+1)\\theta\\) 与 \\(\\pi/2\\) 的接近程度，这会让得到正确解的概率最大化。\ntest 自然的我们会提出几个问题：\nGrover 迭代器怎么具体实现？特别是我们在算法输入中只给定了一个实现 \\(U_f\\) 操作的 Oracal。 Grover 迭代器的最小次数是多少？我们自然希望量子线路越短越好。 量子方案相较于经典方案的优势在哪里？ 我们将在以下几节的内容中一一给出答案。\nGrover 迭代器 # ","date":"2025-03-17","externalUrl":null,"permalink":"/zh-cn/docs/quantum-algorithm/grover/","section":"Docs","summary":"\u003ch2 class=\"relative group\"\u003e概述 \n    \u003cdiv id=\"%E6%A6%82%E8%BF%B0\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E6%A6%82%E8%BF%B0\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e对于无结构的搜索问题，Grover 算法相较于经典算法从理论上提供了平方根级别的加速。\u003c/p\u003e","title":"Grover算法","type":"docs"},{"content":"","date":"2025-03-17","externalUrl":null,"permalink":"/zh-cn/series/quantum-algorithm/","section":"Series","summary":"","title":"Quantum Algorithm","type":"series"},{"content":"","date":"2025-03-17","externalUrl":null,"permalink":"/zh-cn/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":" 为什么要研究群表示论？ # 在第一节中，我们介绍了群的基本定义以及群理论中的一些基本概念，我们使用的数学语言是“抽象”的，这不利于群论的进一步应用。群表示论（更正式地，线性表示理论）就是为了解决这一问题，它可以帮助我们将抽象的群结构具体化到线性变换或矩阵上，使得我们能用线性代数、矩阵论等成熟的工具去分析群的性质。\n群的线性表示 # 定义: 设 \\(G\\) 是一个群，\\(V\\) 是域 \\(K\\) 上的一个向量空间，\\(V\\) 上所有可逆线性变换组成的乘法群记作 \\(\\mathrm{GL}(V)\\)。\\(G\\) 到 \\(\\mathrm{GL}(V)\\) 的一个群同态 \\(\\varphi\\) 称为 \\(G\\) 在域 \\(K\\) 上的一个线性表示（简称为 \\(K\\)-表示或者表示）。\\(V\\) 称为表示空间。若 \\(V\\) 是有限维的，则 \\(V\\) 的维数 \\(\\dim_K V\\) 称为表示的次数（或维数），记作 \\(\\deg \\varphi\\) ；若 \\(V\\) 是无限维的，则称 \\(\\varphi \\) 是 \\(G\\) 的无限维表示。\n","date":"2025-03-17","externalUrl":null,"permalink":"/zh-cn/docs/summary-of-group-theory/group2/","section":"Docs","summary":"\u003ch2 class=\"relative group\"\u003e为什么要研究群表示论？ \n    \u003cdiv id=\"%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%A0%94%E7%A9%B6%E7%BE%A4%E8%A1%A8%E7%A4%BA%E8%AE%BA\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%A0%94%E7%A9%B6%E7%BE%A4%E8%A1%A8%E7%A4%BA%E8%AE%BA\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e在第一节中，我们介绍了群的基本定义以及群理论中的一些基本概念，我们使用的数学语言是“抽象”的，这不利于群论的进一步应用。群表示论（更正式地，线性表示理论）就是为了解决这一问题，它可以帮助我们将抽象的群结构具体化到线性变换或矩阵上，使得我们能用线性代数、矩阵论等成熟的工具去分析群的性质。\u003c/p\u003e","title":"群论：群表示论","type":"docs"},{"content":"","date":"2025-03-15","externalUrl":null,"permalink":"/zh-cn/tags/regular-expression/","section":"Tags","summary":"","title":"Regular Expression","type":"tags"},{"content":"","date":"2025-03-15","externalUrl":null,"permalink":"/zh-cn/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025-03-15","externalUrl":null,"permalink":"/zh-cn/utilities/","section":"Utilities","summary":"","title":"Utilities","type":"utilities"},{"content":"","date":"2025-03-15","externalUrl":null,"permalink":"/zh-cn/tags/utility/","section":"Tags","summary":"","title":"Utility","type":"tags"},{"content":" 群的基本定义 # 一个群 (Group) 是由一个非空集合 \\(G\\) 与其上的二元运算（记为\\(\\circ\\)）构成的代数结构，该二元运算满足以下公理：\n结合律（Associativity）：\\(\\forall a, b, c \\in G\\)，有 \\((a \\circ b) \\circ c = a \\circ (b \\circ c).\\)\n单位元（Identity element）：存在一个元素 \\(e \\in G\\)，使得对任意 \\(a \\in G\\)：\\(e \\circ a = a \\circ e = a.\\)\n逆元（Inverse element）：对任意 \\(a \\in G\\)，存在一个元素 \\(a^{-1} \\in G\\)，满足 \\(a \\circ a^{-1} = a^{-1} \\circ a = e.\\)\n按照以上定义，群中的元素在运算 \\(\\circ\\) 下具有封闭性。\n需要注意的是，集合以及其上定义的群通常会共用一个符号 \\(G\\)，但它们是两个不同的数学对象。群上定义了超出集合概念的运算结构，更正式的情况下记为 \\((G, \\circ)\\)。我们称该集合为群\\(G\\)的基础集（underlying set）。\n最常见的两种二元运算为加法和乘法，而群上仅定义有一种运算，据此可以分出加法群（additive group）和乘法群（multiplicative group）。加法群的单位元即为0，任一元素 \\(x\\) 的逆元为 \\(-x\\)；乘法群的单位元为1，任一元素 \\(x\\) 的逆元为 \\(x^{-1}\\)。此外，排列复合、矩阵乘法、对称差、异或 XOR、函数复合等运算都能构成群。\n群的定义并不要求运算满足交换律，据此可以分出阿贝尔群（Abelian group）和非阿贝尔群（non-Abelian group）。\n群的阶（order）定义为群中元素的个数，记为 \\(|G|\\)。阶为有限的群称为有限群，阶为无穷的群称为无限群。\n基本概念 # 在研究集合时，我们会用到子集，函数和等价关系商等概念。类似的，在研究群时，我们会用到子群，同态和商群等概念。下面分别做介绍。\n子群 # 如果 \\(H\\) 是 \\(G\\) 的一个非空子集，并且 \\(H\\) 在 \\(G\\) 的运算 \\(\\circ\\) 下也构成一个群，那么 \\(H\\) 称为 \\(G\\) 的子群（Subgroup）。记作 \\(H \\leq G\\)。\n子群的条件可以简化为以下判定法则：\n封闭性：\\(\\forall a, b \\in H\\)，有 \\(a \\circ b \\in H\\)。 单位元：群 \\(G\\) 的单位元 \\(e\\) 在 \\(H\\) 中。 逆元：\\(\\forall a \\in H\\)，其逆元 \\(a^{-1} \\in H\\)。 若 \\(H \\neq G\\) 且 \\(H \\leq G\\)，则称 \\(H\\) 为 \\(G\\) 的真子群（Proper subgroup），记作 \\(H \u0026lt; G\\)。\n陪集 # 设 \\(H\\) 是群 \\(G\\) 的一个子群，则可以使用 \\(H\\) 将 \\(G\\) 中的元素划分为若干个不相交且彼此具有相同大小的子集，这些子集称为 \\(H\\) 的陪集（coset）。陪集又可以分出左陪集和右陪集，给定 \\(G\\) 的一个元素 \\(g\\)，则有：\n左陪集（Left coset）：\\(gH = {g \\circ h \\mid h \\in H}\\) 右陪集（Right coset）：\\(Hg = {h \\circ g \\mid h \\in H}\\) 容易看出，\\(H\\) 的陪集的阶数与\\(H\\)的阶数相等，\\(H\\) 同时是自身的左陪集和右陪集。左陪集和右陪集的数量相等，称为 \\(H\\) 在 \\(G\\) 中的指数（index），记作 \\([G:H]\\)。\n一个重要的定理是拉格朗日定理：如果 \\(H\\) 是 \\(G\\) 的子群，那么 \\(|G|=|H|[G:H]\\)。这个定理描述了一个群和它的子群的阶数之间的关系。特别地，如果 \\(G\\) 是有限群，那么可以得到推论：只有整除 \\(|G|\\) 的数才可能是子群的阶，因此素数阶群必为循环群； \\(G\\) 中每个元素的阶都会整除群 \\(G\\) 的阶。\n正规子群 # \\(G\\)的所有元素\\(g\\)对应的左陪集和右陪集相等，即\\(gH=Hg\\)时，\\(H\\) 是 \\(G\\) 的正规子群（normal subgroup），记作 \\(H \\triangleleft G\\)。一个等价的定义是，一个正规子群 \\(H\\) 在其所属群 \\(G\\) 的元素 \\(g\\) 的共轭作用下保持不变，即 \\(gHg^{-1} = H\\)。\n商群 # 可以在陪集构成的集合上赋予一个满足群公理的运算，使之成为商群（quotient group）。正式地，若 \\(H\\) 是群 \\(G\\) 的一个正规子群，则可以在 \\(G\\) 的所有左陪集（或右陪集）集合上定义运算 \\((aH) \\circ (bH) = (a \\circ b)H\\)，这样构造出的代数结构称为商群，记作 \\(G/H\\)。\n事实上，能够证明如果这种商群结构能定义成功，则 \\(H\\) 必定是正规子群。左右陪集不等的情况下无法定义出满足群公理的二元运算，但仍可定义类似的结构，形成一个齐性空间。\n之所以称为“商”群，是因为类似于整数除法，8除以2等于4相当于我们把8个对象分组为了各含4个对象的两个子集。而商群类似于我们使用 \\(H\\) 对 \\(G\\)进行了划分。\n同态与同构 # 设 \\(G\\) 和 \\(H\\) 是两个群, 如果 \\(G\\) 到 \\(H\\) 有一个映射 \\(\\phi\\), 使得 $$ \\phi(ab) = \\phi(a) \\phi(b), \\forall a,b \\in G $$ 那么称 \\(\\phi\\) 是 \\(G\\) 到 \\(H\\) 的一个同态映射，简称为同态。\n如果 \\(\\phi\\) 是单射，则 \\(\\phi\\) 称为单同态；\n如果 \\(\\phi\\) 是满射，则 \\(\\phi\\) 称为满同态；\n如果 \\(\\phi\\) 是双射，则 \\(\\phi\\) 称为同构。此时我们说群 \\(G\\) 和 \\(H\\) 是同构的，记作 \\(G \\cong H\\)。\n显然同态保持群的运算结构，它具有以下基本性质：\n单位元映射到单位元：\\(\\phi(e_G) = e_H\\) 逆元映射到逆元：\\(\\phi(a^{-1}) = \\phi(a)^{-1}\\) 在研究同态时，两个重要概念是：\n核：同态 \\(\\phi: G \\rightarrow H\\) 的核定义为映射到 \\(H\\) 单位元的 \\(G\\) 中所有元素构成的集合： $$ \\ker(\\phi) = {g \\in G \\mid \\phi(g) = e_H} $$\n像：同态 \\(\\phi\\) 的像是 \\(G\\) 中所有元素通过 \\(\\phi\\) 映射得到的 \\(H\\) 的子集： $$ \\text{im}(\\phi) = {\\phi(g) \\mid g \\in G} $$\n可以证明，同态的核是原群的正规子群，而同态的像是目标群的子群。\n第一同构定理：如果 \\(\\phi: G \\rightarrow H\\) 是群同态，则 $$G/\\ker(\\phi) \\cong \\text{im}(\\phi)$$\n这里的概念可能有些复杂，我们举三个例子进行说明：\n1. 从整数群 \\(\\mathbb{Z}\\) 到整数模 \\(n\\) 群 \\(\\mathbb{Z}_n\\) 的映射\n我们构造一个映射： $$ \\phi: \\mathbb{Z} \\rightarrow \\mathbb{Z}_n, \\quad \\phi(k) = k \\operatorname{mod} n $$\n可以快速对该映射的同态性质进行检验，\\(\\forall a,b \\in \\mathbb{Z}\\)， $$ \\phi(a+b) = (a+b) \\operatorname{mod} n $$ $$ \\phi(a) \\oplus \\phi(b) = [(a \\operatorname{mod} n) + (b \\operatorname{mod} n)] \\operatorname{mod} n = (a+b) \\operatorname{mod} n $$ 其中第二个式子利用了模运算的基本性质。可见该映射确实构成了一个群同态。\n我们现在将目光转移到该同态的核与像，显然我们有： $$ \\ker(\\phi) = \\{k \\in \\mathbb{Z} \\,|\\, \\phi(k)=0 \\in \\mathbb{Z}_n \\} = \\{k \\in \\mathbb{Z} \\,|\\, k \\operatorname{mod} n =0 \\} = n\\mathbb{Z} $$ 核由所有能被 \\(n\\) 整除的整数构成，这些元素在映射后都变成 \\(\\mathbb{Z}_n\\) 的单位元“0”。也就是说，这些元素在映射后不可区分。而 $$ \\operatorname{Im}(\\phi) = \\{\\phi(k): k \\in \\mathbb{Z}\\} = \\mathbb{Z}_n $$ 显然这个映射是满射。\n由于 \\(\\phi\\) 是满射，但不是单射，因此它不是一个同构。\n根据第一同构定理， $$ G / \\ker(\\phi) \\cong \\operatorname{Im}(\\phi) \\Longrightarrow \\mathbb{Z} / n \\mathbb{Z} \\cong \\mathbb{Z}_n $$ 也就是说，当我们把 \\(\\mathbb{Z}\\) 按照子群 \\(n\\mathbb{Z}\\) 进行划分后，得到的商群与 \\(\\mathbb{Z}_n\\) 同构。\n2. 从正实数乘法群 \\(\\mathbb{R}^{*}_{+}\\) 到实数加法群 \\(\\mathbb{R}\\) 的对数映射\n我们定义映射： $$ \\phi: \\mathbb{R}^{*}_{+} \\Longrightarrow \\mathbb{R} \\quad \\phi(x) = \\ln(x) $$ 显然我们有： $$ \\phi(x \\times y) = \\ln(xy) = \\ln(x) + \\ln(y) = \\phi(x) + \\phi(y) $$\n因此该映射是一个同态\n$$ \\ker(\\phi) = \\{x \\in \\mathbb{R}^{*}_{+} | \\ln(x) = 0 \\} = \\{ 1 \\} $$\n只有 \\(\\mathbb{R}^{*}_{+}\\) 的单位元1被映射到目标群 \\(\\mathbb{R}\\) 的单位元0。因此 \\(\\phi\\) 是一个单射。\n$$ \\operatorname{Im}(\\phi) = \\{\\ln(x): x \u0026gt; 0\\} = \\mathbb{R} $$\n这也是一个满射。\n因此该映射是一个同构，直观理解就是，乘法对应加法是指数与对数的互逆关系。\n3. 从可逆矩阵群 \\(\\mathrm{GL}_n(\\mathbb{R})\\) 到非零实数乘法群 \\(\\mathbb{R}^*\\) 的行列式映射\n这里 \\(\\mathrm{GL}_n(\\mathbb{R})\\) 是所有 \\(n \\times n\\) 可逆实矩阵的集合，运算是“矩阵乘法”。\n构造映射：\n$$ \\mathrm{GL}_n(\\mathbb{R}) \\rightarrow \\mathbb{R}^* \\quad A \\mapsto \\det(A) $$\n显然对于任意可逆矩阵 \\(A, B\\)，我们有：\n$$ \\det(A B) = \\det(A) \\cdot \\det(B) $$\n因此该映射是一个同态。\n对于核与像，我们有：\n$$ \\ker(\\det) = \\{A \\in \\mathrm{GL}_n(\\mathbb{R}) \\,|\\, \\det(A)=1 \\} $$\n核是所有行列式为1的可逆矩阵构成的集合，通常记为 \\(\\mathrm{SL}_n(\\mathbb{R})\\)。显然该映射不是单射。\n$$ \\operatorname{Im}(\\det) = \\{\\det(A): A \\in \\mathrm{GL}_n(\\mathbb{R})\\} = \\mathbb{R}^* $$\n这是因为给定任意 \\(r \\ne 0\\)，都能找到一个对角矩阵 \\(\\operatorname{diag}(r, 1, 1, \\ldots, 1)\\)，使其行列式值为 \\(r\\)。因此该映射是满射。\n因此该同态不是同构，这体现了尽管行列式把矩阵映射的较为简明，但同一个行列式值的不同矩阵在目标群中被压缩为了同一个点。\n因此，核可以帮助我们发现“映射过程中被合并了哪些元素（信息）”；像可以帮助我们看出“同态覆盖了目标群的哪些部分”。一旦核只有单位元，就意味着没有任何元素被额外折叠，映射是单射。若此时像又是整个目标群，那么两个群就同构。\n示例 # 想象一张在平面上的正方形纸，所有能够将这张正方形纸映射到自身的几何变换（例如旋转、翻折）构成了一个群。我们用 \\(D_4\\) 表示它，常称为“正方形的二面体群”，其基础集中包含八个元素（八种刚体运动），运算则是“连续地做变换”（也就是复合）。为方便描述，我们把顺时针旋转 \\(90^\\circ\\) 记作 \\(r\\)，把绕固定对称轴的一次翻折记作 \\(s\\)。\\(D_4\\) 的八个元素可写为： $$ \\{\\, e,\\; r,\\; r^2,\\; r^3,\\; s,\\; rs,\\; r^2s,\\; r^3s \\}, $$ 其中 \\(e\\) 表示“不动”，即恒等变换；\\(r^k\\) 表示顺时针旋转 \\(90^\\circ\\) 的 \\(k\\) 次方；\\(s\\) 表示一次翻折；\\(r^k s\\) 表示先翻折、再旋转 \\(k\\) 次（或者先旋转 \\(k\\) 次，再翻折，视变换顺序约定而定，但概念上就是“旋转+翻折”的组合）。\n在 \\(D_4\\) 里，任何三个变换复合起来都可以通过结合律减少成两个变换的复合，不会有歧义；不动元 \\(e\\) 对任何元素都满足 \\(e \\circ g = g \\circ e = g\\)；每个变换都有“逆变换”，例如 \\(r\\) 的逆元是 \\(r^3\\)，翻折 \\(s\\) 的逆元就是它本身 \\(s\\)。所以 \\(D_4\\) 确实是一个群。\n再来看子群。\\(D_4\\) 里有一个重要子群，即只做旋转的那部分 \\(\\langle r\\rangle = \\{e,\\, r,\\, r^2,\\, r^3\\}\\)。它的元素个数是4，满足前面提到的三条子群判定标准，故 \\(\\langle r\\rangle\\) 的确是 \\(D_4\\) 的子群。作为子群，\\(\\langle r\\rangle\\) 在全群中的单位元还是同一个 \\(e\\)，逆元也沿用 \\(D_4\\) 的“逆变换”概念。\\(\\langle r\\rangle\\) 本身又是一个循环群。\n如果拿 \\(\\langle r\\rangle\\) 去划分陪集，可以将 \\(D_4\\) 的八个元素划分为两个大小相等的不相交子集：\\(\\langle r\\rangle\\) 自身（它既是一个左陪集，也是一个右陪集），以及 \\(s\\langle r\\rangle = \\{s,\\, rs,\\, r^2s,\\, r^3s\\}\\)。我们可以感受一下这一划分：任意元素若属于第一个子集（只做旋转），或第二个子集（带有翻折），彼此就不会有重叠，也恰好把群里的元素“一分为二”。这说明了指数 \\([D_4 : \\langle r\\rangle]\\) 是2，从而也能验证拉格朗日定理里的 \\(|D_4| = 8\\) 与 \\(|\\langle r\\rangle|=4\\) 的关系：\\(8 = 4 \\times 2\\)。\n继续观察会发现 \\(\\langle r\\rangle\\) 还是 \\(D_4\\) 的一个正规子群，即对每一个 \\(g \\in D_4\\)，都有 \\(g \\langle r\\rangle g^{-1} = \\langle r\\rangle\\)。直观来说，对称地“转一圈”再“转回来”，或者“翻折一下”再“翻回来”，都不会跳出那个纯粹旋转的子群。因为 \\(\\langle r\\rangle\\) 是正规子群，我们可以在它的陪集上赋予群运算，从而形成商群 \\(D_4 / \\langle r\\rangle\\)。这个商群只有两个元素：一个是 \\(\\langle r\\rangle\\) 自身，另一个是 \\(s \\langle r\\rangle\\)。运算定义如下：\\((a\\langle r\\rangle) \\circ (b\\langle r\\rangle) = (a \\circ b)\\langle r\\rangle\\)。读起来可能有点抽象，其实可以把这两个陪集理解成“是否带有翻折”的两种对称类型，整个结构恰好和只有两个元素的群（记为 \\(\\mathbb{Z}_2\\) 或者 \\({0,1}\\)）相似，也就是我们在抽象上把“纯旋转”和“带翻折”当作两个宏观的等价类。\n最后定义一个映射 \\(\\phi: D_4 \\to \\{1, -1\\}\\)（其中 \\(\\{1,-1\\}\\) 可以理解成一个两元素的乘法群），规定凡是“纯旋转”的元素都映射到 \\(1\\)，凡是“带翻折”的元素都映射到 \\(-1\\)。这样便保持了群结构：任何两个纯旋转复合仍是纯旋转，对应 \\(1 \\times 1 = 1\\)；任何翻折与旋转的组合出来还是翻折，对应 \\(1 \\times -1 = -1\\)；两个翻折复合回到纯旋转，对应 \\((-1) \\times (-1) = 1\\)。这映射 \\(\\phi\\) 就是一个群同态。它的核正是 \\(\\langle r\\rangle\\)，对应映到 \\(1\\) 的所有元素；它的像是 \\(\\{1, -1\\}\\)，即整个目标群。按照第一同构定理，我们得到 \\(D_4 / \\langle r\\rangle \\cong \\{1, -1\\}\\)，呼应了上面关于商群的认识。\n","date":"2025-03-15","externalUrl":null,"permalink":"/zh-cn/docs/summary-of-group-theory/group1/","section":"Docs","summary":"\u003ch2 class=\"relative group\"\u003e群的基本定义 \n    \u003cdiv id=\"%E7%BE%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E7%BE%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e一个\u003cem\u003e群\u003c/em\u003e (Group) 是由一个非空集合 \\(G\\) 与其上的二元运算（记为\\(\\circ\\)）构成的代数结构，该二元运算满足以下公理：\u003c/p\u003e","title":"群论：基本概念","type":"docs"},{"content":" RRKM Theory is a Microcanonical Version of TST # RRKM Theory (Rice–Ramsperger–Kassel–Marcus Theory) is indeed often considered a microcanonical extension of Transition State Theory (TST). Both theories share foundational assumptions and are used to describe reaction rates, but they operate within different statistical frameworks:\nTST typically operates within a canonical (constant temperature) ensemble, assuming that the system is in thermal equilibrium with a heat bath. RRKM Theory extends TST to a microcanonical (constant energy) ensemble, allowing for the calculation of unimolecular reaction rates as a function of energy. Common Assumptions in RRKM and TST # Born-Oppenheimer (BO) Approximation: Both theories assume the BO approximation, which separates electronic and nuclear motions due to the large difference in their masses. This allows the potential energy surface (PES) to be treated independently of electronic transitions during the reaction.\nEquilibrium Between Reactants and Activated Complex: Both theories assume that there is a rapid and reversible equilibrium between reactants and the activated (transition) complex. This implies that the population of the activated complex is determined by the equilibrium distribution.\nNo Recrossing of the Transition State: Both theories assume that once the system crosses the transition state, it proceeds to form products without reverting to reactants. This idealization means that the transmission coefficient (κ) is assumed to be close to 1, indicating minimal or no recrossing.\nSeparable Reaction Paths: The reaction path is assumed to be separable from the other degrees of freedom, allowing the reaction coordinate to be treated independently. This simplifies the analysis by focusing on the primary pathway of the reaction.\nLimitations # Given the assumptions outlined above, RRKM Theory and TST have several limitations that constrain their applicability:\nSingle Reaction Surface:\nLimitation: These theories are only applicable to reactions that proceed along a single, well-defined potential energy surface (PES) without significant contributions from multiple pathways or surfaces. Implication: Reactions involving multiple competing pathways or surface crossings cannot be accurately described using RRKM or TST. Long Transition State Lifetimes Relative to IVR:\nLimitation: Both theories require that the lifetime of the transition state is much longer than the timescale of Intramolecular Vibrational Redistribution (IVR). Implication: If IVR is not sufficiently rapid, the energy within the activated complex may not be uniformly redistributed, violating the statistical energy distribution assumption and leading to inaccurate rate predictions. Transmission Coefficient Near 1:\nLimitation: The assumption that the transmission coefficient (κ) is close to 1 implies negligible recrossing of the transition state. Implication: In systems where recrossing is significant, the transmission coefficient deviates from 1, rendering the theories\u0026rsquo; rate predictions unreliable. Inapplicability to Barrierless Reactions:\nLimitation: Both RRKM and TST rely on the existence of a well-defined transition state with an associated energy barrier. Implication: Barrierless reactions, which proceed without a significant energy barrier or distinct transition state, cannot be accurately described by these theories. Alternative models, such as direct dynamics simulations, are required for such reactions. Assumption of Separable Reaction Paths:\nLimitation: The assumption that the reaction coordinate is separable from other degrees of freedom may not hold in systems where there is strong coupling between the reaction coordinate and other vibrational modes. Implication: In such cases, the energy distribution cannot be treated independently, leading to potential inaccuracies in rate calculations. Neglect of Quantum Effects:\nLimitation: Both theories primarily treat nuclear motion classically and may not account for quantum mechanical effects such as tunneling, especially significant in reactions involving light atoms like hydrogen. Implication: For reactions where quantum effects play a crucial role, RRKM and TST may underestimate or misrepresent the actual reaction rates. Summary # RRKM Theory extends TST to a microcanonical framework, maintaining similar foundational assumptions. Both theories assume the Born-Oppenheimer approximation, equilibrium between reactants and the activated complex, no recrossing, and separable reaction paths. Limitations: Applicable only to single reaction surfaces. Require that the transition state lifetime is much longer than IVR. Assume the transmission coefficient is near 1. Not suitable for barrierless reactions. Depend on the separability of reaction paths and often neglect quantum effects. ","date":"25 October 2024","externalUrl":null,"permalink":"/docs/tst-and-rrkm-/test/","section":"Docs","summary":"\u003ch3 class=\"relative group\"\u003e\u003cstrong\u003eRRKM Theory is a Microcanonical Version of TST\u003c/strong\u003e \n    \u003cdiv id=\"rrkm-theory-is-a-microcanonical-version-of-tst\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#rrkm-theory-is-a-microcanonical-version-of-tst\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eRRKM Theory (Rice–Ramsperger–Kassel–Marcus Theory)\u003c/strong\u003e is indeed often considered a microcanonical extension of \u003cstrong\u003eTransition State Theory (TST)\u003c/strong\u003e. Both theories share foundational assumptions and are used to describe reaction rates, but they operate within different statistical frameworks:\u003c/p\u003e","title":"Assumptions and Limitations in RRKM and TST","type":"docs"},{"content":" 这篇文章也用于评估KaTeX的渲染性能。 原文为英文，该文本由自然语言处理程序翻译得到。 引言 # 考虑一个一般的基元反应： $$ a \\mathrm{A} + b \\mathrm{B} \\rightarrow c \\mathrm{C} + d \\mathrm{D} $$ 根据惯例，为了使反应从左到右进行时速率为正，我们对生成物选择正的导数，对反应物选择负的导数。微分速率方程可以写为： $$ \\frac{1}{c} \\frac{\\mathrm{d}[\\mathrm{C}]}{\\mathrm{d}t} = \\frac{1}{d} \\frac{\\mathrm{d}[\\mathrm{D}]}{\\mathrm{d}t} = -\\frac{1}{a} \\frac{\\mathrm{d}[\\mathrm{A}]}{\\mathrm{d}t} = -\\frac{1}{b} \\frac{\\mathrm{d}[\\mathrm{B}]}{\\mathrm{d}t} = k [\\mathrm{A}]^{a} [\\mathrm{B}]^b $$ 反应的级数是速率方程中反应物的指数之和。总反应级数是每个反应物对应的反应级数之和。速率常数 \\(k\\) 与温度有关，但与反应物的浓度无关。\n最常见的基元反应是零级、一级和二级反应，而三级及以上的反应很少见。以下将推导这些反应的积分速率方程。\n零级反应 # 对于零级反应，速率方程为： $$ \\frac{\\mathrm{d}[\\mathrm{A}]}{\\mathrm{d}t} = -k $$ 对这个方程进行积分得到： $$ [\\mathrm{A}] = -kt + [\\mathrm{A}(0)] $$ 这个方程描述了反应物浓度随时间的变化。\n一级反应 # 对于一级反应，速率方程为： $$ \\frac{\\mathrm{d}[\\mathrm{A}]}{\\mathrm{d}t} = -k[\\mathrm{A}] $$ 对这个方程进行积分得到： $$ \\ln [\\mathrm{A}] = -kt + \\ln [\\mathrm{A}(0)] $$ 这个方程描述了反应物浓度随时间的变化。\n二级反应 # \\(2 \\mathrm{A} \\rightarrow \\mathrm{products}\\) # 对于反应 \\(2 \\mathrm{A} \\rightarrow \\mathrm{products}\\)，微分速率方程为： $$ \\frac{1}{2} \\frac{\\mathrm{d}[\\mathrm{A}]}{\\mathrm{d}t} = k[\\mathrm{A}]^2 $$ 设 \\(x\\) 表示反应的进度，即 \\(\\mathrm{A}\\) 的浓度变化。则有： $$ [\\mathrm{A}] = [\\mathrm{A}(0)] - 2x $$ 代入速率方程得到： $$ \\frac{\\mathrm{d}x}{\\mathrm{d}t} = k ([\\mathrm{A}(0)] - 2x)^2 $$ 分离变量： $$ \\int \\frac{\\mathrm{d}x}{([\\mathrm{A}(0)] - 2x)^2} = k \\int \\mathrm{d}t $$ 对两边积分： $$ -\\frac{1}{2[\\mathrm{A}]} + \\frac{1}{2[\\mathrm{A}(0)]} = kt $$ 重新整理： $$ \\frac{1}{[\\mathrm{A}]} = 2kt + \\frac{1}{[\\mathrm{A}(0)]} $$ 这个方程描述了反应物浓度随时间的变化。\n\\(\\mathrm{A} + \\mathrm{B} \\rightarrow \\mathrm{products}\\) # 对于反应 \\(\\mathrm{A} + \\mathrm{B} \\rightarrow \\mathrm{products}\\)，微分速率方程为： $$ -\\frac{\\mathrm{d}[\\mathrm{A}]}{\\mathrm{d}t} = -\\frac{\\mathrm{d}[\\mathrm{B}]}{\\mathrm{d}t} = k[\\mathrm{A}][\\mathrm{B}] $$ 设 \\(x\\) 表示反应的进度。则有： $$ [\\mathrm{A}] = [\\mathrm{A}(0)] - x, \\quad [\\mathrm{B}] = [\\mathrm{B}(0)] - x $$ 代入速率方程： $$ \\frac{\\mathrm{d}x}{\\mathrm{d}t} = k([\\mathrm{A}(0)] - x)([\\mathrm{B}(0)] - x) $$ 分离变量： $$ \\int \\frac{\\mathrm{d}x}{([\\mathrm{A}(0)] - x)([\\mathrm{B}(0)] - x)} = k \\int \\mathrm{d}t $$ 使用部分分数分解： $$ \\frac{1}{([\\mathrm{A}(0)] - x)([\\mathrm{B}(0)] - x)} = \\frac{1}{[\\mathrm{A}(0)] - [\\mathrm{B}(0)]} \\left(\\frac{1}{[\\mathrm{B}(0)] - x} - \\frac{1}{[\\mathrm{A}(0)] - x}\\right) $$ 对两边积分： $$ \\frac{1}{[\\mathrm{A}(0)] - [\\mathrm{B}(0)]} \\ln \\frac{[\\mathrm{A}][\\mathrm{B}(0)]}{[\\mathrm{A}(0)][\\mathrm{B}]} = kt $$ 这个方程描述了两个反应物的浓度随时间的变化。\n三级反应 # \\(\\text{A}+\\text{B}+\\text{C} \\rightarrow \\text{products}\\) # 对于含有三个不同反应物的三级反应，微分速率方程为： $$ -\\frac{d[\\text{A}]}{dt} = -\\frac{d[\\text{B}]}{dt} = -\\frac{d[\\text{C}]}{dt} = k[\\text{A}][\\text{B}][\\text{C}] $$\n设 \\(x\\) 表示反应的进度。则有： $$ [\\text{A}] = [\\text{A}(0)] - x, \\quad [\\text{B}] = [\\text{B}(0)] - x, \\quad [\\text{C}] = [\\text{C}(0)] - x $$\n代入速率方程： $$ \\frac{dx}{dt} = k([\\text{A}(0)] - x)([\\text{B}(0)] - x)([\\text{C}(0)] - x) $$\n分离变量：\n$$ \\int \\frac{dx}{([\\text{A}(0)] - x)([\\text{B}(0)] - x)([\\text{C}(0)] - x)} = k \\int dt $$\n使用部分分数分解：\n$$ \\frac{1}{([\\text{A}(0)] - x)([\\text{B}(0)] - x)([\\text{C}(0)] - x)} = \\frac{A}{[\\text{A}(0)] - x} + \\frac{B}{[\\text{B}(0)] - x} + \\frac{C}{[\\text{C}(0)] - x} $$\n两边乘以 \\(([\\text{A}(0)] - x)([\\text{B}(0)] - x)([\\text{C}(0)] - x)\\) 并展开，通过匹配各项确定系数 \\(A\\)、\\(B\\) 和 \\(C\\)。解得：\n$$ A = \\frac{1}{([\\text{B}(0)] - [\\text{A}(0)])([\\text{C}(0)] - [\\text{A}(0)])}, \\quad B = \\frac{1}{([\\text{A}(0)] - [\\text{B}(0)])([\\text{C}(0)] - [\\text{B}(0)])}, \\quad C = \\frac{1}{([\\text{A}(0)] - [\\text{C}(0)])([\\text{B}(0)] - [\\text{C}(0)])} $$\n因此，积分变为\n$$ A \\int \\frac{dx}{[\\text{A}(0)] - x} + B \\int \\frac{dx}{[\\text{B}(0)] - x} + C \\int \\frac{dx}{[\\text{C}(0)] - x} = kt + \\text{常数} $$\n对两边积分并合并常数，得到积分速率方程：\n$$ \\frac{1}{([\\text{B}(0)] - [\\text{A}(0)])([\\text{C}(0)] - [\\text{A}(0)])} \\ln\\left(\\frac{[\\text{B}][\\text{C}][\\text{A}(0)]}{[\\text{B}(0)][\\text{C}(0)][\\text{A}]}\\right) + \\frac{1}{([\\text{A}(0)] - [\\text{B}(0)])([\\text{C}(0)] - [\\text{B}(0)])} \\ln\\left(\\frac{[\\text{A}][\\text{C}][\\text{B}(0)]}{[\\text{A}(0)][\\text{C}(0)][\\text{B}]}\\right) + \\frac{1}{([\\text{A}(0)] - [\\text{C}(0)])([\\text{B}(0)] - [\\text{C}(0)])} \\ln\\left(\\frac{[\\text{A}][\\text{B}][\\text{C}(0)]}{[\\text{A}(0)][\\text{B}(0)][\\text{C}]}\\right) = kt $$\n\\(2 \\text{A} + \\text{B} \\rightarrow \\text{products}\\) # 从微分速率方程开始：\n$$ \\frac{1}{2} \\frac{d[\\text{A}]}{dt} = -\\frac{d[\\text{B}]}{dt} = k[\\text{A}]^2[\\text{B}] $$\n设 \\(x\\) 表示反应的进度，\\(x\\) 为 \\(\\text{B}\\) 的浓度变化。则有\n$$ [\\text{A}] = [\\text{A}(0)] - 2x, \\quad [\\text{B}] = [\\text{B}(0)] - x $$\n代入速率方程得到\n$$ \\frac{dx}{dt} = k ([\\text{A}(0)] - 2x)^2 ([\\text{B}(0)] - x) $$\n分离变量：\n$$ \\int \\frac{dx}{([\\text{A}(0)] - 2x)^2 ([\\text{B}(0)] - x)} = k \\int dt $$\n使用部分分数分解，\n$$ \\frac{1}{([\\text{A}(0)] - 2x)^2 ([\\text{B}(0)] - x)} = \\frac{A}{[\\text{A}(0)] - 2x} + \\frac{B}{([\\text{A}(0)] - 2x)^2} + \\frac{C}{[\\text{B}(0)] - x} $$\n两边乘以 \\(([\\text{A}(0)] - 2x)^2 ([\\text{B}(0)] - x)\\) 并展开，通过匹配各项确定系数 \\(A\\)、\\(B\\) 和 \\(C\\)。解得\n$$ A = -\\frac{2}{\\left( [\\text{A}(0)] - 2[\\text{B}(0)] \\right)^2}, \\quad B = -\\frac{2}{[\\text{A}(0)] - 2[\\text{B}(0)]}, \\quad C = \\frac{1}{\\left( [\\text{A}(0)] - 2[\\text{B}(0)] \\right)^2} $$\n因此，积分变为\n$$ \\int \\frac{dx}{([\\text{A}(0)] - 2x)^2 ([\\text{B}(0)] - x)} = -\\frac{1}{\\left( [\\text{A}(0)] - 2[\\text{B}(0)] \\right)} \\left( \\frac{1}{[\\text{A}]} - \\frac{1}{[\\text{A}(0)]} \\right) - \\frac{1}{\\left( [\\text{A}(0)] - 2[\\text{B}(0)] \\right)^2} \\ln \\frac{[\\text{A}][\\text{B}(0)]}{[\\text{A}(0)][\\text{B}]} $$\n对两边积分并合并常数，得到积分速率方程：\n$$ \\frac{1}{[\\text{A}(0)] - 2[\\text{B}(0)]} \\left( \\frac{1}{[\\text{A}(0)]} - \\frac{1}{[\\text{A}]} \\right) + \\frac{1}{\\left( [\\text{A}(0)] - 2[\\text{B}(0)] \\right)^2} \\ln \\frac{[\\text{A}][\\text{B}(0)]}{[\\text{A}(0)][\\text{B}]} = kt $$\n","date":"2024-10-25","externalUrl":null,"permalink":"/zh-cn/docs/differential-and-integral-rate-laws-for-common-types-of-reactions/test/","section":"Docs","summary":"\u003cdiv\n  \n    class=\"flex px-4 py-3 rounded-md bg-primary-100 dark:bg-primary-900\"\n  \u003e\n\n  \u003cspan\n    \n      class=\"text-primary-400 ltr:pr-3 rtl:pl-3 flex items-center\"\n    \u003e\n\n    \n\n  \u003cspan class=\"relative block icon\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e\u003cpath fill=\"currentColor\" d=\"M506.3 417l-213.3-364c-16.33-28-57.54-28-73.98 0l-213.2 364C-10.59 444.9 9.849 480 42.74 480h426.6C502.1 480 522.6 445 506.3 417zM232 168c0-13.25 10.75-24 24-24S280 154.8 280 168v128c0 13.25-10.75 24-23.1 24S232 309.3 232 296V168zM256 416c-17.36 0-31.44-14.08-31.44-31.44c0-17.36 14.07-31.44 31.44-31.44s31.44 14.08 31.44 31.44C287.4 401.9 273.4 416 256 416z\"/\u003e\u003c/svg\u003e\n\n  \u003c/span\u003e\n\n\n  \u003c/span\u003e\n\n  \u003cspan\n    \n      class=\"dark:text-neutral-300\"\n    \u003e这篇文章也用于评估KaTeX的渲染性能。\u003c/span\u003e\n\u003c/div\u003e\n\n\n  \n\n\n\n\u003cdiv\n  \n    class=\"flex px-4 py-3 rounded-md bg-primary-100 dark:bg-primary-900\"\n  \u003e\n\n  \u003cspan\n    \n      class=\"text-primary-400 ltr:pr-3 rtl:pl-3 flex items-center\"\n    \u003e\n\n    \n\n  \u003cspan class=\"relative block icon\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e\u003cpath fill=\"currentColor\" d=\"M506.3 417l-213.3-364c-16.33-28-57.54-28-73.98 0l-213.2 364C-10.59 444.9 9.849 480 42.74 480h426.6C502.1 480 522.6 445 506.3 417zM232 168c0-13.25 10.75-24 24-24S280 154.8 280 168v128c0 13.25-10.75 24-23.1 24S232 309.3 232 296V168zM256 416c-17.36 0-31.44-14.08-31.44-31.44c0-17.36 14.07-31.44 31.44-31.44s31.44 14.08 31.44 31.44C287.4 401.9 273.4 416 256 416z\"/\u003e\u003c/svg\u003e\n\n  \u003c/span\u003e\n\n\n  \u003c/span\u003e\n\n  \u003cspan\n    \n      class=\"dark:text-neutral-300\"\n    \u003e原文为英文，该文本由自然语言处理程序翻译得到。\u003c/span\u003e\n\u003c/div\u003e\n\n\n\n\u003ch2 class=\"relative group\"\u003e引言 \n    \u003cdiv id=\"%E5%BC%95%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%BC%95%E8%A8%80\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e考虑一个一般的基元反应：\n$$\na \\mathrm{A} + b \\mathrm{B} \\rightarrow c \\mathrm{C} + d \\mathrm{D}\n$$\n根据惯例，为了使反应从左到右进行时速率为正，我们对生成物选择正的导数，对反应物选择负的导数。微分速率方程可以写为：\n$$\n\\frac{1}{c} \\frac{\\mathrm{d}[\\mathrm{C}]}{\\mathrm{d}t} = \\frac{1}{d} \\frac{\\mathrm{d}[\\mathrm{D}]}{\\mathrm{d}t} = -\\frac{1}{a} \\frac{\\mathrm{d}[\\mathrm{A}]}{\\mathrm{d}t} = -\\frac{1}{b} \\frac{\\mathrm{d}[\\mathrm{B}]}{\\mathrm{d}t} = k [\\mathrm{A}]^{a} [\\mathrm{B}]^b\n$$\n反应的级数是速率方程中反应物的指数之和。总反应级数是每个反应物对应的反应级数之和。速率常数 \\(k\\) 与温度有关，但与反应物的浓度无关。\u003c/p\u003e","title":"常见反应类型的微分速率法则与积分速率法则","type":"docs"},{"content":"","externalUrl":null,"permalink":"/zh-cn/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/zh-cn/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]